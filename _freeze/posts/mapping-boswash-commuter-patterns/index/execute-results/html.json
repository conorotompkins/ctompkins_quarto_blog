{
  "hash": "006b8093bd63e4baaef8fab05f3c90ba",
  "result": {
    "markdown": "---\ntitle: \"Mapping BosWash commuter patterns with Flowmap.blue\"\nsubtitle: \"\"\nsummary: \"\"\nauthors: [Conor Tompkins]\ntags: [Census, Commuter patterns]\ncategories: [Census, Commuter patterns]\ndate: 2020-09-25\nlastmod: 2020-09-25T12:58:17-04:00\nfeatured: false\ndraft: false\nimage: flowmapblue_sheet_screen.png\neditor_options: \n  chunk_output_type: console\nexecute:\n  echo: true\n  warning: false\n  message: false\n---\n\n\nThis map shows the commuter patterns in the [Northeast Megalopolis/Acela Corridor/BosWash metro area](https://en.wikipedia.org/wiki/Northeast_megalopolis). I pulled the data from the [Census Longitudinal Employer-Household Dynamics (LODES)](https://lehd.ces.census.gov/data/) system via the `{lehdr}` package. The map was created through the [Flowmap.blue](https://flowmap.blue/) tool, which makes interactive maps of movement between areas. Flowmap.blue also exposes a bunch of cool features, like animating and clustering connections, among others.\n\nYou can view a full version of the map [here](https://flowmap.blue/1lxe0FRjCu5FG2SVbX5m1vDMfVAXzS0i_bnwxxPNuCX8?v=41.620996,-75.378680,4.93,0,0&a=0&as=1&b=1&bo=75&c=1&ca=1&d=1&fe=1&lt=1&lfm=ALL&col=interpolateViridis&f=50). <iframe src=\"https://flowmap.blue/1lxe0FRjCu5FG2SVbX5m1vDMfVAXzS0i_bnwxxPNuCX8?v=41.620996,-75.378680,4.93,0,0&a=0&as=1&b=1&bo=75&c=1&ca=1&d=1&fe=1&lt=1&lfm=ALL&col=interpolateViridis&f=50\" width=1000 height=800\"></iframe>\n\n## Code\n\nThis code is what I used to query the LODES data and aggregate it. First, load the required libraries.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(tidyverse)\nlibrary(tidycensus)\nlibrary(janitor)\nlibrary(lehdr)\nlibrary(tigris)\nlibrary(sf)\nlibrary(ggraph)\nlibrary(tidygraph)\nlibrary(googlesheets4)\nlibrary(googledrive)\n\noptions(tigris_use_cache = TRUE,\n        scipen = 999,\n        digits = 4)\n```\n:::\n\n\nThis code gets the `main` and `aux` LODES data for each state that I name in the `states` object. I then combine the data into lodes_combined and check that there are no duplicate origin-destination pairs. Be warned that these files are large (100-500MB each), and can take a bit to read into R, depending on your machine.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n#get lodes\nstates <- c(\"pa\", \"wv\", \"va\", \"dc\", \"de\",\n            \"md\", \"ny\", \"ri\", \"ct\", \"ma\", \"vt\", \"nh\", \"me\")\n\nlodes_od_main <- grab_lodes(state = states, year = 2017, \n                            lodes_type = \"od\", job_type = \"JT00\", \n                            segment = \"S000\", state_part = \"main\", \n                            agg_geo = \"county\",\n                            use_cache = TRUE) %>% \n  select(state, w_county, h_county, S000, year) %>% \n  rename(commuters = S000)\n\nlodes_od_aux <- grab_lodes(state = states, year = 2017, \n                           lodes_type = \"od\", job_type = \"JT00\", \n                           segment = \"S000\", state_part = \"aux\", \n                           agg_geo = \"county\",\n                           use_cache = TRUE) %>% \n  select(state, w_county, h_county, S000, year) %>% \n  rename(commuters = S000)\n\nlodes_combined <- bind_rows(lodes_od_main, lodes_od_aux)\n```\n:::\n\n\nThis code pulls the geometry for the states from the TIGER shapefile API:\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncounties_combined <- tigris::counties(state = c(\"PA\", \"NY\", \"NJ\", \"MD\", \n                                                \"WV\", \"DE\", \"VA\", \n                                                \"DC\", \"MA\", \"CT\", \"VT\", \n                                                \"RI\", \"NH\", \"ME\"), \n                                      cb = TRUE) %>% \n  arrange(STATEFP) %>% \n  left_join(fips_codes %>% distinct(state_code, state_name), by = c(\"STATEFP\" = \"state_code\"))\n\ncounties_combined %>% \n  ggplot() +\n  geom_sf(aes(fill = state_name))\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-3-1.png){width=672}\n:::\n:::\n\n\nThe next step is to calculate the centroid of each county that will be used in the final map.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nnode_pos <- counties_combined %>% \n  mutate(centroid = map(geometry, st_centroid),\n         x = map_dbl(centroid, 1),\n         y = map_dbl(centroid, 2)) %>% \n  select(GEOID, NAME, x, y) %>% \n  arrange(GEOID) %>% \n  st_drop_geometry() %>% \n  as_tibble() %>% \n  select(-NAME) %>%\n  rename(lon = x,\n         lat = y) %>% \n  mutate(id = row_number()) %>% \n  select(id, GEOID, lat, lon)\n```\n:::\n\n\nThen I add the county and state name to the node positions so the name is intelligible.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nnode_pos <- node_pos %>% \n  left_join(st_drop_geometry(counties_combined), by = c(\"GEOID\" = \"GEOID\")) %>% \n  mutate(county_name = str_c(NAME, \"County\", sep = \" \"),\n         name = str_c(county_name, state_name, sep = \", \"))\n\nnode_pos <- node_pos %>% \n  select(id, name, lat, lon, GEOID)\n\nnode_pos\n```\n:::\n\n::: {.cell}\n\n:::\n\n::: {.cell}\n::: {.cell-output .cell-output-stdout}\n```\nRows: 433\nColumns: 5\n$ id    <dbl> 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 1…\n$ name  <chr> \"Fairfield County, Connecticut\", \"Hartford County, Connecticut\",…\n$ lat   <dbl> 41.27, 41.81, 41.79, 41.46, 41.41, 41.49, 41.86, 41.83, 39.09, 3…\n$ lon   <dbl> -73.39, -72.73, -73.25, -72.54, -72.93, -72.10, -72.34, -71.99, …\n$ GEOID <chr> \"09001\", \"09003\", \"09005\", \"09007\", \"09009\", \"09011\", \"09013\", \"…\n```\n:::\n:::\n\n\nThis processes the LODES origin-destination data and creates the node-edge network graph object that will be fed into the Flowmap.blue service.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nnetwork_graph <- lodes_combined %>%\n  semi_join(counties_combined, by = c(\"w_county\" = \"GEOID\")) %>%\n  semi_join(counties_combined, by = c(\"h_county\" = \"GEOID\")) %>%\n  select(h_county, w_county, commuters) %>% \n  as_tbl_graph(directed = TRUE) %>% \n  activate(edges) %>% \n  filter(commuters >= 500,\n         #!edge_is_loop()\n  ) %>%\n  activate(nodes) %>%\n  arrange(name)\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nnodes <- network_graph %>%\n  activate(nodes) %>%\n  as_tibble()\n\nglimpse(nodes)\n```\n:::\n\n::: {.cell}\n\n:::\n\n::: {.cell}\n::: {.cell-output .cell-output-stdout}\n```\nRows: 433\nColumns: 1\n$ name <chr> \"09001\", \"09003\", \"09005\", \"09007\", \"09009\", \"09011\", \"09013\", \"0…\n```\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nedges <- network_graph %>% \n  activate(edges) %>% \n  as_tibble() %>% \n  rename(origin = from,\n         dest = to,\n         count = commuters) %>% \n  arrange(desc(count))\n\nglimpse(edges)\n```\n:::\n\n::: {.cell}\n\n:::\n\n::: {.cell}\n::: {.cell-output .cell-output-stdout}\n```\nRows: 3,309\nColumns: 3\n$ origin <dbl> 128, 161, 121, 149, 61, 121, 138, 210, 112, 2, 127, 125, 138, 1…\n$ dest   <dbl> 128, 161, 128, 149, 61, 121, 128, 210, 112, 2, 127, 125, 138, 1…\n$ count  <dbl> 558308, 483764, 475073, 468885, 450975, 398535, 384941, 371075,…\n```\n:::\n:::\n\n\nFinally, this code checks that the node position data matches up with the nodes from the network object. If these checks fail, the origin-destination pairs will be mapped to the wrong geographic coordinates.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n#check that nodes match up\nall(node_pos$GEOID == nodes$name)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] TRUE\n```\n:::\n\n```{.r .cell-code}\nidentical(node_pos$GEOID, nodes$name)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] TRUE\n```\n:::\n\n```{.r .cell-code}\nlength(node_pos$GEOID) == length(nodes$name)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] TRUE\n```\n:::\n:::\n\n\nThis code creates the metadata that Flowmap.blue requires and loads the data into Google Sheets.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmy_properties <- c(\n  \"title\"=\"BosWash regional US commuter flow\",\n  \"description\"=\"Miniumum 500 commuters per origin-destination pair\",\n  \"source.name\"=\"2017 US Census LODES\",\n  \"source.url\"=\"https://lehd.ces.census.gov/data/\",\n  \"createdBy.name\"=\"Conor Tompkins\",\n  \"createdBy.url\"=\"https://ctompkins.netlify.app/\",\n  \"mapbox.mapStyle\"=NA,\n  \"flows.sheets\" = \"flows\",\n  \"colors.scheme\"=\"interpolateViridis\",\n  \"colors.darkMode\"=\"yes\",\n  \"animate.flows\"=\"no\",\n  \"clustering\"=\"yes\"\n)\n\nproperties <- tibble(property=names(my_properties)) %>%\n  mutate(value=my_properties[property])\n\ngs4_auth()\n\ngoogledrive::drive_auth()\n\ndrive_trash(\"lodes_flowmapblue\")\n\nss <- gs4_create(\"lodes_flowmapblue\", sheets = list(properties = properties,\n                                                    locations = node_pos,\n                                                    flows = edges))\n```\n:::\n\n\nThe final step is to allow the Google Sheet to be read by anyone with the link, and copy the Sheet's link to [Flowmap.blue](https://flowmap.blue/)\n\n\n::: {.cell}\n::: {.cell-output-display}\n![](flowmapblue_sheet_screen.png){width=360}\n:::\n:::\n\n\n## References\n\n-   https://doodles.mountainmath.ca/blog/2020/01/06/flow-maps/\n-   https://jamgreen.github.io/lehdr/articles/getting_started.html\n",
    "supporting": [
      "index_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}