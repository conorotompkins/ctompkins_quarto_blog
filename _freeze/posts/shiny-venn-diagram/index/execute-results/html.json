{
  "hash": "285746017eb1e2a7e741fc7a211182b1",
  "result": {
    "markdown": "---\ntitle: Making a Venn diagram in Shiny\nauthor: 'Conor Tompkins'\ndate: '2022-03-12'\nslug: shiny-venn-diagram\ncategories: [shiny]\ntags: []\nsubtitle: ''\nsummary: ''\nlastmod: '2022-03-12T10:34:16-05:00'\nfeatured: no\nprojects: []\neditor_options: \n  chunk_output_type: console\n---\n\n\n\n\n### Introduction\n\nThis blog post is about making Venn diagrams work in Shiny, and the issues I ran into with `shiny::nearPoints()`. I show how this impacted my initial approach, and discuss the underlying issue.\n\nTLDR; `shiny::nearPoints()` doesn't work with dataframes containing list-columns the way I expected\n\n### Background\n\nI have been working on a Shiny app that I will use to plan birdwatching trips. It uses the `{ebirdst}` package to pull abundance data for hundreds of species of birds in 27x27km tiles in North America. A major feature of the app will be the ability to compare how similar two areas (tiles) are. This compares the abundance for a species in a given tile in a given month. I wanted to include a Venn diagram that shows which species are exclusive to each tile. The user can click on the Venn diagram to see the species associated with each segment of the Venn diagram.\n\nThis involves making a venn diagram in `ggplot2` and extracting the segment that the user clicks on with `nearPoints()`. This was more challenging than I had anticipated.\n\n### Venn diagram data\n\n`nearPoints()` requires:\n\n-   `df`: a data frame with x and y coordinates it can interpret\n-   `coordinfo`: the user click coordinates as captured from the ui\n\nI use the `ggVennDiagram` package to make the venn diagram plot. This package uses `ggplot2`, but does a lot of pre-processing of the data beforehand. This made it difficult to get access to the `df` for `nearPoints()`.\n\nThis is an example of a `ggVennDiagram` plot. It takes a `list` object, turns that into a dataframe, and then uses `sf` to draw the circles.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(tidyverse)\nlibrary(ggVennDiagram)\n\ngenes <- paste(\"gene\",1:100,sep=\"\")\nset.seed(20210419)\nx <- list(A=sample(genes,30),\n          B=sample(genes,50))\n\nggVennDiagram(x)\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-1-1.png){width=672}\n:::\n:::\n\n\nLooking under the hood of `ggVennDiagram()` shows the pre-processing steps:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nvenn <- Venn(x)\ndata <- process_data(venn)\n```\n:::\n\n\n`Venn()` creates an object with slots representing the two sets A and B\n\n\n::: {.cell}\n\n```{.r .cell-code}\nVenn(x)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nAn object of class \"Venn\"\nSlot \"sets\":\n$A\n [1] \"gene27\" \"gene76\" \"gene57\" \"gene33\" \"gene78\" \"gene39\" \"gene63\" \"gene41\"\n [9] \"gene66\" \"gene17\" \"gene16\" \"gene69\" \"gene75\" \"gene9\"  \"gene68\" \"gene3\" \n[17] \"gene34\" \"gene54\" \"gene19\" \"gene83\" \"gene2\"  \"gene40\" \"gene87\" \"gene60\"\n[25] \"gene61\" \"gene24\" \"gene44\" \"gene93\" \"gene53\" \"gene7\" \n\n$B\n [1] \"gene84\"  \"gene36\"  \"gene37\"  \"gene47\"  \"gene91\"  \"gene46\"  \"gene92\" \n [8] \"gene33\"  \"gene67\"  \"gene73\"  \"gene25\"  \"gene5\"   \"gene63\"  \"gene2\"  \n[15] \"gene83\"  \"gene56\"  \"gene77\"  \"gene10\"  \"gene12\"  \"gene95\"  \"gene76\" \n[22] \"gene53\"  \"gene99\"  \"gene19\"  \"gene31\"  \"gene86\"  \"gene80\"  \"gene65\" \n[29] \"gene48\"  \"gene100\" \"gene89\"  \"gene58\"  \"gene35\"  \"gene30\"  \"gene21\" \n[36] \"gene44\"  \"gene72\"  \"gene18\"  \"gene45\"  \"gene42\"  \"gene1\"   \"gene27\" \n[43] \"gene90\"  \"gene14\"  \"gene43\"  \"gene26\"  \"gene96\"  \"gene17\"  \"gene16\" \n[50] \"gene29\" \n\n\nSlot \"names\":\n[1] \"A\" \"B\"\n```\n:::\n:::\n\n\n`process_data()` turns those slots into dataframes with `sf` columns representing the segment polygons.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nvenn <- Venn(x)\nprocess_data(venn)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nAn object of class \"VennPlotData\"\nSlot \"setEdge\":\nSimple feature collection with 2 features and 5 fields\nGeometry type: LINESTRING\nDimension:     XY\nBounding box:  xmin: 125 ymin: 250 xmax: 875 ymax: 750\nCRS:           NA\n# A tibble: 2 × 6\n  id                                        geometry component item  count name \n  <chr>                                 <LINESTRING> <chr>     <nam> <int> <chr>\n1 1     (500 716, 493.065 720.007, 485.954 723.777,… setEdge   <chr>    30 A    \n2 2     (500 284, 506.935 279.998, 514.046 276.243,… setEdge   <chr>    50 B    \n\nSlot \"setLabel\":\nSimple feature collection with 2 features and 3 fields\nGeometry type: POINT\nDimension:     XY\nBounding box:  xmin: 250 ymin: 780 xmax: 750 ymax: 780\nCRS:           NA\n# A tibble: 2 × 4\n  id     geometry component name \n  <chr>   <POINT> <chr>     <chr>\n1 1     (250 780) setLabel  A    \n2 2     (750 780) setLabel  B    \n\nSlot \"region\":\nSimple feature collection with 3 features and 5 fields\nGeometry type: POLYGON\nDimension:     XY\nBounding box:  xmin: 125 ymin: 250 xmax: 875 ymax: 750\nCRS:           NA\n# A tibble: 3 × 6\n  id                                        geometry component item  count name \n  <chr>                                    <POLYGON> <chr>     <lis> <int> <chr>\n1 1     ((500 716, 492.317 711.329, 484.878 706.459… region    <chr>    19 A    \n2 2     ((500 284, 507.683 288.649, 515.122 293.497… region    <chr>    39 B    \n3 12    ((507.683 711.328, 515.122 706.458, 522.317… region    <chr>    11 A..B \n```\n:::\n:::\n\n\nThe `region` slot is most important for my purposes. It contains the `sf` polygons for the segments and the distinct counts exclusive to each segment.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nprocess_data(venn) %>% \n  .@region\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nSimple feature collection with 3 features and 5 fields\nGeometry type: POLYGON\nDimension:     XY\nBounding box:  xmin: 125 ymin: 250 xmax: 875 ymax: 750\nCRS:           NA\n# A tibble: 3 × 6\n  id                                        geometry component item  count name \n  <chr>                                    <POLYGON> <chr>     <lis> <int> <chr>\n1 1     ((500 716, 492.317 711.329, 484.878 706.459… region    <chr>    19 A    \n2 2     ((500 284, 507.683 288.649, 515.122 293.497… region    <chr>    39 B    \n3 12    ((507.683 711.328, 515.122 706.458, 522.317… region    <chr>    11 A..B \n```\n:::\n\n```{.r .cell-code}\nprocess_data(venn) %>% \n  .@region %>% \n  ggplot(aes(fill = name)) +\n  geom_sf()\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-5-1.png){width=672}\n:::\n:::\n\n\nI thought using `nearPoints()` would be pretty easy once I intercepted the `region` object from the preprocessing steps. I was wrong.\n\n### Shiny app error\n\nThis basic Shiny app will reproduce the error that `nearPoints()` generates:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(shiny)\nlibrary(tidyverse)\nlibrary(ggVennDiagram)\nlibrary(sf)\n\n#ui\nui <- fluidPage(\n  \n  titlePanel(\"Shiny Venn Diagram\"),\n  \n  mainPanel(\n    plotOutput(\"venn_diagram\", click = \"plot_click\"),\n    tableOutput(\"venn_table\")\n  )\n)\n\ngenes <- paste(\"gene\",1:1000,sep=\"\")\nset.seed(20210419)\nx <- list(A=sample(genes,300),\n          B=sample(genes,525))\n\nvenn <- Venn(x)\nvenn_data <- process_data(venn)@region %>% \n  mutate(centroid = st_point_on_surface(geometry),\n         x = map_dbl(centroid, 1),\n         y = map_dbl(centroid, 2)) %>% \n  select(x, y, name, geometry)\n\n#server\nserver <- function(input, output){\n  \n  output$venn_diagram <- renderPlot({\n    \n    venn_data %>% \n      ggplot(aes(x, y, fill = name, label = name)) +\n      geom_sf() +\n      geom_label()\n    \n  })\n  \n  output$venn_table <- renderTable({\n    \n    req(input$plot_click)\n    \n    nearPoints(venn_data, #this is the issue\n               input$plot_click,\n               threshold = 100)\n    \n  })\n  \n}\n```\n:::\n\n\nThis is the error:\n\n> ```         \n> Warning: Error in <-: number of items to replace is not a multiple of replacement length\n> 104: print.xtable\n> 98: transform\n> 97: func\n> 95: f\n> 94: Reduce\n> 85: do\n> 84: hybrid_chain\n> 83: renderFunc\n> 82: output$venn_table\n> 1: shiny::runApp\n> ```\n\n### The fix\n\nWrapping the `venn_data` object in `st_drop_geometry()` drops the `sf` list-column and turns it back into a regular dataframe.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(shiny)\nlibrary(tidyverse)\nlibrary(ggVennDiagram)\nlibrary(sf)\n\n#ui\nui <- fluidPage(\n  \n  titlePanel(\"Shiny Venn Diagram\"),\n  \n  mainPanel(\n    plotOutput(\"venn_diagram\", click = \"plot_click\"),\n    tableOutput(\"venn_table\")\n  )\n)\n\ngenes <- paste(\"gene\",1:1000,sep=\"\")\nset.seed(20210419)\nx <- list(A=sample(genes,300),\n          B=sample(genes,525))\n\nvenn <- Venn(x)\nvenn_data <- process_data(venn)@region %>% \n  mutate(centroid = st_point_on_surface(geometry),\n         x = map_dbl(centroid, 1),\n         y = map_dbl(centroid, 2)) %>% \n  select(x, y, name, geometry)\n\n#server\nserver <- function(input, output){\n  \n  output$venn_diagram <- renderPlot({\n    \n    venn_data %>% \n      ggplot(aes(x, y, fill = name, label = name)) +\n      geom_sf() +\n      geom_label()\n    \n  })\n  \n  output$venn_table <- renderTable({\n    \n    req(input$plot_click)\n    \n    nearPoints(st_drop_geometry(venn_data), #the fix\n               input$plot_click,\n               threshold = 100)\n    \n  })\n  \n}\n```\n:::\n\n\n### Working Shiny App\n\nThis is a working example of a Venn diagram in Shiny. `input$plot_click` captures the coordinates of the click and `nearPoints()` returns a dataframe of the information about the segment the user clicked on. The ID of the segment is in the `name` column.\n\n<iframe src=\"https://conorotompkins.shinyapps.io/nearpoints_listcols/?_ga=2.224776090.1006061501.1647011895-2001510754.1647011895\" height=\"550\" width=\"720\" style=\"border: 1px solid #464646;\" data-external=\"1\">\n\n</iframe>\n",
    "supporting": [
      "index_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}