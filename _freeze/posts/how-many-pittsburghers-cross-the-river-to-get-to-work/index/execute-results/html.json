{
  "hash": "c14dc5031f2a31751df92643cf285c81",
  "result": {
    "markdown": "---\n# Documentation: https://sourcethemes.com/academic/docs/managing-content/\ntitle: \"How Many Pittsburghers Cross the River to Get to Work\"\nsubtitle: \"\"\nsummary: \"\"\nauthors: [Conor Tompkins]\ntags: [R, Pittsburgh, Allegheny County, Census, WPRDC]\ncategories: [R, Pittsburgh, Allegheny County, Census, WPRDC]\ndate: 2020-02-09\nlastmod: 2020-08-12T11:47:20-04:00\nfeatured: false\ndraft: false\nimage: featured.png\nprojects: []\neditor_options: \n  chunk_output_type: console\nexecute:\n  echo: true\n  warning: false\n  message: false\n---\n\n\nThis post focuses on how many rivers Pittsburghers cross to get to work. I use the U.S. Census Bureau LEHD Origin-Destination Employment Statistics (LODES) [dataset](https://lehd.ces.census.gov/data/) to draw lines between \"home\" census tracts and \"work\" census tracts, and then count how many \"commuter lines\" intersect with the 3 main rivers in Pittsburgh. This calculation is done in straight lines \"as the crow flies\", not accounting for actual road routes.\n\n## TLDR\nA plurality of commuters don't cross any rivers, and none cross three.\n![](high_resolution_bar_chart.png)\n\n![](high_resolution_facet_map.png)\n\nMany commuters in the Golden Triangle and neighborhoods to the east don't cross rivers to get to work. Commuters from the North and South Hills areas usually cross one river. Commuters from Sewickley, Coraopolis, and those that live close to the airport are most likely to cross two rivers.\n\n## Data munging and analysis\n\nI use the \"pa_od_aux_JT00_2017.csv\" file as shown here:\n![](lodes_screenshot.png){width=80% height=80%}\n\nIn my analysis I use many of the standard `{tidyverse}` packages, `{sf}`, `{tidycensus}`, `{tidygraph}`, and `{ggraph}`:\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(tidyverse)\nlibrary(vroom)\nlibrary(sf)\nlibrary(tigris)\nlibrary(tidycensus)\nlibrary(tidygraph)\nlibrary(ggraph)\n```\n:::\n\n\n\n\nThe first step is to read in the geographies crosswalk:\n\n::: {.cell}\n\n```{.r .cell-code}\ngeo_crosswalk <- vroom(\"post_data/pa_xwalk.csv.gz\", col_types = cols(.default = \"c\"))\n\ngeo_crosswalk\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 421,545 × 43\n   tabblk2010    st    stusps stname cty   ctyname trct  trctname bgrp  bgrpname\n   <chr>         <chr> <chr>  <chr>  <chr> <chr>   <chr> <chr>    <chr> <chr>   \n 1 420912030002… 42    PA     Penns… 42091 Montgo… 4209… 2030 (M… 4209… 2 (Trac…\n 2 420912070013… 42    PA     Penns… 42091 Montgo… 4209… 2070.01… 4209… 3 (Trac…\n 3 420912070013… 42    PA     Penns… 42091 Montgo… 4209… 2070.01… 4209… 3 (Trac…\n 4 420710144022… 42    PA     Penns… 42071 Lancas… 4207… 144.02 … 4207… 2 (Trac…\n 5 420710144022… 42    PA     Penns… 42071 Lancas… 4207… 144.02 … 4207… 2 (Trac…\n 6 420710134002… 42    PA     Penns… 42071 Lancas… 4207… 134 (La… 4207… 2 (Trac…\n 7 420710144022… 42    PA     Penns… 42071 Lancas… 4207… 144.02 … 4207… 2 (Trac…\n 8 420710144022… 42    PA     Penns… 42071 Lancas… 4207… 144.02 … 4207… 2 (Trac…\n 9 420710144022… 42    PA     Penns… 42071 Lancas… 4207… 144.02 … 4207… 2 (Trac…\n10 420710144022… 42    PA     Penns… 42071 Lancas… 4207… 144.02 … 4207… 2 (Trac…\n# ℹ 421,535 more rows\n# ℹ 33 more variables: cbsa <chr>, cbsaname <chr>, zcta <chr>, zctaname <chr>,\n#   stplc <chr>, stplcname <chr>, ctycsub <chr>, ctycsubname <chr>,\n#   stcd116 <chr>, stcd116name <chr>, stsldl <chr>, stsldlname <chr>,\n#   stsldu <chr>, stslduname <chr>, stschool <chr>, stschoolname <chr>,\n#   stsecon <chr>, stseconname <chr>, trib <chr>, tribname <chr>, tsub <chr>,\n#   tsubname <chr>, stanrc <chr>, stanrcname <chr>, necta <chr>, …\n```\n:::\n:::\n\n\nThis downloads the census tract shapefiles:\n\n::: {.cell}\n\n```{.r .cell-code}\nallegheny_tracts <- get_decennial(geography = \"tract\",\n                           variables = c(total_pop = \"P001001\"),\n                           state = \"PA\",\n                           county = \"Allegheny County\",\n                           geometry = TRUE,\n                           output = \"wide\",\n                           year = 2010)\n\nallegheny_tracts\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nSimple feature collection with 402 features and 3 fields\nGeometry type: MULTIPOLYGON\nDimension:     XY\nBounding box:  xmin: -80.36087 ymin: 40.19435 xmax: -79.68885 ymax: 40.67494\nGeodetic CRS:  NAD83\n# A tibble: 402 × 4\n   GEOID       NAME                          total_pop                  geometry\n   <chr>       <chr>                             <dbl>        <MULTIPOLYGON [°]>\n 1 42003412002 Census Tract 4120.02, Allegh…      4865 (((-80.07936 40.58043, -…\n 2 42003413100 Census Tract 4131, Allegheny…      6609 (((-80.06788 40.60846, -…\n 3 42003413300 Census Tract 4133, Allegheny…      4742 (((-80.03822 40.55349, -…\n 4 42003416000 Census Tract 4160, Allegheny…      1636 (((-79.77054 40.56028, -…\n 5 42003417200 Census Tract 4172, Allegheny…      1260 (((-79.78122 40.54113, -…\n 6 42003423000 Census Tract 4230, Allegheny…      2801 (((-79.90692 40.4871, -7…\n 7 42003426800 Census Tract 4268, Allegheny…      5369 (((-79.94408 40.53137, -…\n 8 42003428100 Census Tract 4281, Allegheny…      1242 (((-79.97941 40.47738, -…\n 9 42003429500 Census Tract 4295, Allegheny…      4212 (((-80.01937 40.55063, -…\n10 42003431100 Census Tract 4311, Allegheny…      3380 (((-80.05242 40.49402, -…\n# ℹ 392 more rows\n```\n:::\n:::\n\n\nThis is the [shapefile](https://data.wprdc.org/dataset/allegheny-county-major-rivers) of the rivers:\n\n::: {.cell}\n\n```{.r .cell-code}\nrivers <- st_read(\"post_data/Allegheny_County_Major_Rivers/Allegheny_County_Major_Rivers.shp\") %>% \n  group_by(NAME) %>% \n  summarize() %>% \n  filter(!is.na(NAME))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nReading layer `Allegheny_County_Major_Rivers' from data source \n  `/Users/conorotompkins/Documents/github_repos/ctompkins_quarto_blog/posts/how-many-pittsburghers-cross-the-river-to-get-to-work/post_data/Allegheny_County_Major_Rivers/Allegheny_County_Major_Rivers.shp' \n  using driver `ESRI Shapefile'\nSimple feature collection with 4 features and 4 fields\nGeometry type: POLYGON\nDimension:     XY\nBounding box:  xmin: -80.23017 ymin: 40.19435 xmax: -79.68877 ymax: 40.66965\nGeodetic CRS:  WGS 84\n```\n:::\n\n```{.r .cell-code}\nrivers\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nSimple feature collection with 3 features and 1 field\nGeometry type: POLYGON\nDimension:     XY\nBounding box:  xmin: -80.23017 ymin: 40.19435 xmax: -79.68877 ymax: 40.66965\nGeodetic CRS:  WGS 84\n# A tibble: 3 × 2\n  NAME                                                                  geometry\n* <chr>                                                            <POLYGON [°]>\n1 Allegheny River   ((-80.01324 40.44201, -80.01323 40.44203, -80.01316 40.4421…\n2 Monongahela River ((-80.01541 40.43983, -80.01531 40.43984, -80.01519 40.4396…\n3 Ohio River        ((-80.01329 40.44192, -80.01423 40.4447, -80.01433 40.4447,…\n```\n:::\n:::\n\n\nThese are the rivers:\n\n::: {.cell}\n\n```{.r .cell-code}\nrivers %>% \n  ggplot() +\n    geom_sf(aes(color = NAME), show.legend = FALSE) +\n    geom_sf_label(aes(label = NAME, fill = NAME), show.legend = FALSE) +\n    theme_graph()\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-6-1.png){width=672}\n:::\n:::\n\n\nThis shows the outlines of the tracts used in the analysis.\n\n::: {.cell}\n\n```{.r .cell-code}\nallegheny_tracts %>% \n  ggplot() +\n    geom_sf() +\n    theme_minimal()\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-7-1.png){width=672}\n:::\n:::\n\n\nNext I read in the main LODES data. This is a big file, so it takes a moment.\n\n::: {.cell}\n\n```{.r .cell-code}\ndf <- vroom(\"post_data/pa_od_main_JT00_2017.csv.gz\", col_types = cols(.default = \"c\")) %>% \n  mutate(S000 = as.numeric(S000)) %>% \n  select(h_geocode, w_geocode, S000)\n\ndf\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 5,034,208 × 3\n   h_geocode       w_geocode        S000\n   <chr>           <chr>           <dbl>\n 1 420010301022005 420010301011003     1\n 2 420010303002001 420010301011003     1\n 3 420010301023038 420010301011012     1\n 4 420010314011078 420010301011012     1\n 5 420010301011027 420010301011016     1\n 6 420010301011033 420010301011016     1\n 7 420010301011038 420010301011016     1\n 8 420010301011116 420010301011016     1\n 9 420010301011123 420010301011016     1\n10 420010302001018 420010301011016     1\n# ℹ 5,034,198 more rows\n```\n:::\n:::\n\n\nNext I summarize the number of commuters per home-work tract combination. The original file uses census block codes, which are too granular for this analysis. I link the blocks to census tracts and aggregate to that level.\n\n::: {.cell}\n\n```{.r .cell-code}\ndf_tracts_summarized <- df %>% \n  group_by(h_geocode, w_geocode) %>% \n  summarize(commuters = sum(S000)) %>% \n  ungroup() %>% \n  arrange(desc(commuters))\n\ndf_tracts_summarized <- df_tracts_summarized %>% \n  left_join(geo_crosswalk %>% select(tabblk2010, trct), by = c(\"h_geocode\" = \"tabblk2010\")) %>% \n  rename(h_tract = trct) %>% \n  left_join(geo_crosswalk %>% select(tabblk2010, trct), by = c(\"w_geocode\" = \"tabblk2010\")) %>% \n  rename(w_tract = trct)\n\ndf_tracts_summarized <- df_tracts_summarized %>% \n  group_by(h_tract, w_tract) %>% \n  summarize(commuters = sum(commuters)) %>% \n  ungroup() %>% \n  arrange(desc(commuters))\n\ndf_tracts_summarized <- df_tracts_summarized %>% \n  semi_join(allegheny_tracts, by = c(\"h_tract\" = \"GEOID\")) %>% \n  semi_join(allegheny_tracts, by = c(\"w_tract\" = \"GEOID\"))\n\n# df_tracts_summarized %>% \n#    summarize(jobs = sum(commuters))\n# 479006 total commuters\n```\n:::\n\n\nThis code finds the center of each tract, which I use as the nodes in the network plots:\n\n::: {.cell}\n\n```{.r .cell-code}\nallegheny_tracts <- allegheny_tracts %>% \n  arrange(GEOID)\n\nallegheny_tracts_centroids <- cbind(allegheny_tracts,\n                                    st_coordinates(st_centroid(allegheny_tracts))) %>% \n  st_set_geometry(NULL) %>% \n  as_tibble() %>% \n  rename(x = X,\n         y = Y) %>% \n  select(GEOID, x, y)\n```\n:::\n\n\nThis shows that the centroids correctly appear in the center of each tract:\n\n::: {.cell}\n\n```{.r .cell-code}\nallegheny_tracts %>% \n  ggplot() +\n    geom_sf() +\n    geom_point(data = allegheny_tracts_centroids, aes(x, y), size = .2) +\n    geom_sf(data = rivers, aes(color = NAME), show.legend = FALSE) +\n    geom_sf_label(data = rivers, aes(color = NAME, label = NAME),\n                  show.legend = FALSE) +\n    theme_void()\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-11-1.png){width=672}\n:::\n:::\n\n\nHere I filter on commuter lines that have at least 25 commuters.\n\n::: {.cell}\n\n```{.r .cell-code}\ng <- df_tracts_summarized %>% \n  as_tbl_graph(directed = TRUE) %>% \n  activate(edges) %>% \n  filter(commuters > 25)\n\ng\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tbl_graph: 402 nodes and 2969 edges\n#\n# A directed multigraph with 17 components\n#\n# Edge Data: 2,969 × 3 (active)\n    from    to commuters\n   <int> <int>     <dbl>\n 1     1     1       723\n 2     2     1       620\n 3     2     2       488\n 4     3     1       487\n 5     4     1       442\n 6     5     1       399\n 7     6     1       371\n 8     7     1       364\n 9     8     1       358\n10     9     1       355\n# ℹ 2,959 more rows\n#\n# Node Data: 402 × 1\n  name       \n  <chr>      \n1 42003020100\n2 42003409000\n3 42003191800\n# ℹ 399 more rows\n```\n:::\n\n```{.r .cell-code}\n# df_tracts_summarized %>%\n#   as_tbl_graph(directed = TRUE) %>%\n#   activate(edges) %>%\n#   filter(commuters > 25) %>%\n#   as_tibble() %>%\n#   summarize(jobs = sum(commuters))\n# 184404 total commuters\n```\n:::\n\n\nHere I set a manual layout for the `ggraph` object. I use the centroids of the census tracts as the nodes in the network graph.\n\n::: {.cell}\n\n```{.r .cell-code}\nnode_pos <- allegheny_tracts_centroids\n\nmanual_layout <- create_layout(graph = g,\n                               layout = node_pos)\n\nmanual_layout %>% \n  as_tibble()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 402 × 7\n   GEOID           x     y name        .ggraph.orig_index .ggraph.index circular\n   <chr>       <dbl> <dbl> <chr>                    <int>         <int> <lgl>   \n 1 42003010300 -80.0  40.4 42003020100                  1             1 FALSE   \n 2 42003020100 -80.0  40.4 42003409000                  2             2 FALSE   \n 3 42003020300 -80.0  40.5 42003191800                  3             3 FALSE   \n 4 42003030500 -80.0  40.4 42003412001                  4             4 FALSE   \n 5 42003040200 -80.0  40.4 42003411000                  5             5 FALSE   \n 6 42003040400 -79.9  40.4 42003456003                  6             6 FALSE   \n 7 42003040500 -80.0  40.4 42003191700                  7             7 FALSE   \n 8 42003040600 -80.0  40.4 42003413100                  8             8 FALSE   \n 9 42003040900 -80.0  40.4 42003473100                  9             9 FALSE   \n10 42003050100 -80.0  40.4 42003426300                 10            10 FALSE   \n# ℹ 392 more rows\n```\n:::\n:::\n\n\nThis graphs the commuter lines on top of the census tracts and rivers:\n\n::: {.cell}\n\n```{.r .cell-code}\nggraph(manual_layout) +\n  geom_sf(data = allegheny_tracts, color = \"dark grey\", fill = NA) +\n  geom_sf(data = rivers, aes(color = NAME), show.legend = FALSE) +\n  geom_edge_fan(aes(edge_width = log10(commuters), \n                    edge_alpha = log10(commuters)),\n                arrow = arrow(length = unit(.5, 'lines')), \n                start_cap = circle(.1, 'lines'),\n                end_cap = circle(.2, 'lines'),\n                color = \"white\",\n                strength = .5) +\n  scale_edge_width_continuous(range = c(.1, 1)) +\n  scale_edge_alpha_continuous(range = c(.01, .4)) +\n  labs(x = NULL,\n       y = NULL,\n       title = \"Where do people commute from/to for work?\",\n       subtitle = \"Excludes within-tract commuters\",\n       caption = \"Based on 2017 US Census LODES dataset | @conor_tompkins\") +\n  theme_graph() +\n  theme(legend.background = element_rect(fill = \"black\"),\n        legend.text = element_text(color = \"white\"),\n        legend.title = element_text(color = \"white\"),\n        panel.background = element_rect(fill = \"black\"))\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-14-1.png){width=672}\n:::\n:::\n\n\nThis calculates the centroids I will use to draw lines later on:\n\n::: {.cell}\n\n```{.r .cell-code}\nallegheny_lines <- cbind(allegheny_tracts, st_coordinates(st_centroid(allegheny_tracts))) %>% \n  select(-c(NAME, total_pop)) %>% \n  st_drop_geometry()\n\nallegheny_lines %>% \n  ggplot() +\n    geom_point(aes(X, Y)) +\n    theme_minimal()\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-15-1.png){width=672}\n:::\n:::\n\n\nHere I calculate the edges and nodes for the network graph:\n\n::: {.cell}\n\n```{.r .cell-code}\ndf_edges <- g %>% \n  activate(edges) %>% \n  as_tibble()\n\n# df_edges %>%\n#   summarize(commuters = sum(commuters))\n# 184404 total commuters\n\ndf_nodes <- g %>% \n  activate(nodes) %>% \n  as_tibble() %>% \n  mutate(id = row_number())\n```\n:::\n\n\nThe `df_lines` is pivoted long so there is a \"to\" and \"from\" row for each commuter line:\n\n::: {.cell}\n\n```{.r .cell-code}\ndf_lines <- df_edges %>% \n  mutate(line_id = row_number()) %>% \n  pivot_longer(c(from, to), names_to = \"point_type\", values_to = \"edge_id\")\n\ndf_lines\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 5,938 × 4\n   commuters line_id point_type edge_id\n       <dbl>   <int> <chr>        <int>\n 1       723       1 from             1\n 2       723       1 to               1\n 3       620       2 from             2\n 4       620       2 to               1\n 5       488       3 from             2\n 6       488       3 to               2\n 7       487       4 from             3\n 8       487       4 to               1\n 9       442       5 from             4\n10       442       5 to               1\n# ℹ 5,928 more rows\n```\n:::\n\n```{.r .cell-code}\n# df_lines %>%\n#   distinct(line_id, commuters) %>%\n#   summarize(jobs = sum(commuters))\n# 184404 total commuters\n```\n:::\n\n\nSince some commuter \"lines\" are really just points that start and end at the same centroid, I separate the commuter \"lines\" from the \"points\" for purposes of manipulating the geometries.\n\n::: {.cell}\n\n```{.r .cell-code}\ndf_line_types <- df_lines %>% \n  pivot_wider(names_from = point_type, values_from = edge_id) %>% \n  mutate(line_type = case_when(from == to ~ \"point\",\n                               from != to ~ \"linestring\")) %>% \n  pivot_longer(cols = c(from, to), names_to = \"edge_type\", values_to = \"edge_id\")\n\ndf_line_types\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 5,938 × 5\n   commuters line_id line_type  edge_type edge_id\n       <dbl>   <int> <chr>      <chr>       <int>\n 1       723       1 point      from            1\n 2       723       1 point      to              1\n 3       620       2 linestring from            2\n 4       620       2 linestring to              1\n 5       488       3 point      from            2\n 6       488       3 point      to              2\n 7       487       4 linestring from            3\n 8       487       4 linestring to              1\n 9       442       5 linestring from            4\n10       442       5 linestring to              1\n# ℹ 5,928 more rows\n```\n:::\n\n```{.r .cell-code}\n# df_line_types %>%\n#   distinct(line_id, commuters) %>%\n#   summarize(commuters = sum(commuters))\n# # 184404 total commuters\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\ndf_linestrings <- df_line_types %>% \n  filter(line_type == \"linestring\")\n\ndf_points <- df_line_types %>% \n  filter(line_type == \"point\")\n```\n:::\n\n\nThis creates the geometries for the lines, points, and rivers. Then I set them all to the same coordinate system with `st_set_crs`.\n\n::: {.cell}\n\n```{.r .cell-code}\ndf_linestrings <- df_linestrings %>% \n  left_join(df_nodes, by = c(\"edge_id\" = \"id\")) %>% \n  left_join(allegheny_lines, by = c(\"name\" = \"GEOID\")) %>% \n  st_as_sf(coords = c(\"X\", \"Y\")) %>% \n  group_by(line_id, commuters) %>%\n  summarise() %>% # union points into lines using our created lineid\n  st_cast(\"LINESTRING\") %>% \n  st_set_crs(4326)\n\n# df_linestrings %>% \n#   ungroup() %>% \n#   st_drop_geometry() %>% \n#   summarize(commuters = sum(commuters))\n\n# 167409 commuters that change tracts\n\ndf_points <- df_points %>% \n  left_join(df_nodes, by = c(\"edge_id\" = \"id\")) %>% \n  left_join(allegheny_lines, by = c(\"name\" = \"GEOID\")) %>% \n  st_as_sf(coords = c(\"X\", \"Y\")) %>% \n  group_by(line_id, commuters) %>%\n  summarise() %>%\n  st_cast(\"POINT\") %>% \n  st_set_crs(4326)\n\n# df_points %>% \n#   ungroup() %>% \n#   st_drop_geometry() %>% \n#   summarize(commuters = sum(commuters))\n\n# 16995 commuters that stay within a tract\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nrivers <- rivers %>% \n  st_set_crs(4326)\n```\n:::\n\n\nHere I calculate which commuter lines intersect with which rivers using `st_intersects`:\n\n::: {.cell}\n\n```{.r .cell-code}\ndf_linestrings_intersect <- df_linestrings %>% \n  ungroup() %>% \n  mutate(intersects_ohio = st_intersects(., rivers %>% \n                                            filter(NAME == \"Ohio River\")) %>% as.logical(),\n         intersects_allegheny = st_intersects(., rivers %>% \n                                                filter(NAME == \"Allegheny River\")) %>% as.logical(),\n         intersects_monongahela = st_intersects(., rivers %>% \n                                                  filter(NAME == \"Monongahela River\")) %>% as.logical())\n\ndf_commuter_rivers <- df_linestrings_intersect %>% \n  pivot_longer(c(contains(\"intersects\")), names_to = \"river_intersected\", values_to = \"value\") %>% \n  mutate(value = case_when(is.na(value) ~ FALSE,\n                           !is.na(value) ~ value))\n \n# df_commuter_rivers %>%\n#   distinct(line_id, commuters) %>%\n#   summarize(jobs = sum(commuters))\n\n# 167409 commuters that change tracts\n```\n:::\n\n\nThis shows that the intersection calculation was successful:\n\n::: {.cell}\n\n```{.r .cell-code}\ndf_commuter_rivers %>% \n  filter(value == TRUE) %>% \n  ggplot() +\n    geom_sf(data = allegheny_tracts, color = NA, show.legend = FALSE) +\n    geom_sf(data = rivers, \n            aes(color = NAME),\n            show.legend = FALSE) +\n    geom_sf(aes(geometry = geometry,\n                size = commuters),\n            show.legend = TRUE) +\n    facet_wrap(~river_intersected,\n               ncol = 1) +\n    guides(color = FALSE,\n           size = FALSE) +\n    theme_graph() +\n    scale_size_continuous(range = c(.1, .5))\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-23-1.png){width=672}\n:::\n:::\n\n\nThis combines the dataframes with the lines and points, and then summarizes to count how many of the geometries intersected with a river:\n\n::: {.cell}\n\n```{.r .cell-code}\n#this was double counting\ndf_commuter_rivers_combined <- df_commuter_rivers %>% \n  bind_rows(df_points %>% \n              mutate(value = FALSE))\n\n#use for lookup\ndf_lines_that_cross_rivers <- df_commuter_rivers_combined %>% \n  group_by(line_id) %>% \n  summarize(rivers_crossed = sum(value)) %>% \n  ungroup()\n\n#find the distinct line_ids and then summarize \ndf_commuter_rivers_summary <- df_commuter_rivers_combined %>% \n  distinct(line_id, commuters) %>% \n  left_join(df_lines_that_cross_rivers) %>% \n  group_by(rivers_crossed) %>% \n  summarize(commuters = sum(commuters)) %>% \n  ungroup()\n  \n\n# df_commuter_rivers_summary %>% \n#   summarize(commuters = sum(commuters))\n# 184404 total commuters\n\ndf_commuter_rivers_summary %>% \n  ggplot(aes(rivers_crossed, commuters)) +\n    geom_col(color = \"black\") +\n    geom_text(aes(y = commuters + 5000, label = scales::comma(commuters))) +\n    scale_y_continuous(labels = scales::comma) +\n    labs(title = \"Commuter travel patterns\",\n         subtitle = \"2017 U.S. Census LODES dataset\",\n         x = \"Rivers crossed\",\n         y = \"Number of commuters\",\n         caption = \"@conor_tompkins\") +\n    theme_bw()\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-24-1.png){width=672}\n:::\n:::\n\n\n\n\n\nIt is always reassuring when your analysis doesn't stray to far from conventional wisdom. Very few Pittsburghers in the dataset cross two rivers to get to work, and none cross three.\n\n## Mapping commuter patterns\n\nThe next step is to put this data on a map, since it is obviously spatial. The goal is to calculate the percentage of each census tract's \"from\" commuters that crossed zero, one, two, and 3 rivers.\n\nThis prepares the edge data to be used to make a chloropleth map:\n\n::: {.cell}\n\n```{.r .cell-code}\ndf_lines_chloro <- df_edges %>% \n  mutate(line_id = row_number()) %>% \n  pivot_longer(c(from, to), names_to = \"point_type\", values_to = \"edge_id\")\n\ndf_lines_chloro\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 5,938 × 4\n   commuters line_id point_type edge_id\n       <dbl>   <int> <chr>        <int>\n 1       723       1 from             1\n 2       723       1 to               1\n 3       620       2 from             2\n 4       620       2 to               1\n 5       488       3 from             2\n 6       488       3 to               2\n 7       487       4 from             3\n 8       487       4 to               1\n 9       442       5 from             4\n10       442       5 to               1\n# ℹ 5,928 more rows\n```\n:::\n\n```{.r .cell-code}\n# df_lines_chloro %>%\n#   distinct(line_id, commuters) %>%\n#   summarize(commuters = sum(commuters))\n# 184404 total commuters\n```\n:::\n\n\nThe next few steps are largely just coercing the geometry to do what I want it to do. Interested parties can read the code.\n\n::: {.cell}\n\n```{.r .cell-code}\ndf_line_types_chloro <- df_lines_chloro %>% \n  pivot_wider(names_from = point_type, values_from = edge_id) %>% \n  mutate(line_type = case_when(from == to ~ \"point\",\n                               from != to ~ \"linestring\")) %>% \n  pivot_longer(cols = c(from, to), names_to = \"edge_type\", values_to = \"edge_id\")\n\n# df_line_types_chloro %>%\n#    distinct(line_id, commuters) %>%\n#    summarize(commuters = sum(commuters))\n#184404 total commuters\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\ndf_linestrings_chloro <- df_line_types_chloro %>% \n  filter(line_type == \"linestring\")\n\n# df_linestrings_chloro %>%\n#   distinct(line_id, commuters) %>%\n#   summarize(commuters = sum(commuters))\n#167409 commuters that change tracts\n\ndf_linestrings_chloro_lookup <- df_linestrings_chloro %>% \n  select(line_id, edge_type, edge_id) %>% \n  pivot_wider(names_from = edge_type, values_from = edge_id)\n\ndf_points_chloro <- df_line_types %>% \n  filter(line_type == \"point\")\n\n# df_points_chloro %>%\n#   distinct(line_id, commuters) %>%\n#   summarize(commuters = sum(commuters))\n#16995 commuters that stay within a tract\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\ndf_linestrings_chloro <- df_linestrings_chloro %>% \n  left_join(df_nodes, by = c(\"edge_id\" = \"id\")) %>% \n  left_join(allegheny_lines, by = c(\"name\" = \"GEOID\")) %>% \n  st_as_sf(coords = c(\"X\", \"Y\")) %>% \n  group_by(line_id, commuters) %>%\n  summarise() %>% # union points into lines using our created lineid\n  st_cast(\"LINESTRING\") %>% \n  st_set_crs(4326) %>% \n  left_join(df_linestrings_chloro_lookup, by = c(\"line_id\" = \"line_id\")) %>% \n  left_join(df_nodes, by = c(\"from\" = \"id\")) %>% \n  left_join(allegheny_lines, by = c(\"name\" = \"GEOID\"))\n\n# df_linestrings_chloro %>%\n#   ungroup() %>%\n#   st_drop_geometry() %>%\n#   summarize(commuters = sum(commuters))\n#167409 commuters that change tracts\n\ndf_points_chloro <- df_points_chloro %>% \n  left_join(df_nodes, by = c(\"edge_id\" = \"id\")) %>% \n  left_join(allegheny_lines, by = c(\"name\" = \"GEOID\")) %>% \n  st_as_sf(coords = c(\"X\", \"Y\")) %>% \n  group_by(line_id, name, commuters) %>%\n  st_cast(\"POINT\") %>% \n  st_set_crs(4326)\n\n# df_points_chloro %>%\n#   ungroup() %>%\n#   st_drop_geometry() %>%\n#   distinct(line_id, commuters) %>%\n#   summarize(commuters = sum(commuters))\n#16995 commuters that stay within a tract\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\ndf_linestrings_chloro_intersect <- df_linestrings_chloro %>% \n  ungroup() %>% \n  mutate(intersects_ohio = st_intersects(., rivers %>% \n                                            filter(NAME == \"Ohio River\")) %>% as.logical(),\n         intersects_allegheny = st_intersects(., rivers %>% \n                                                filter(NAME == \"Allegheny River\")) %>% as.logical(),\n         intersects_monongahela = st_intersects(., rivers %>% \n                                                  filter(NAME == \"Monongahela River\")) %>% as.logical()) %>% \n  st_set_geometry(NULL) %>% \n  select(-c(from, to)) %>% \n  rename(from = name)\n\n# df_linestrings_chloro_intersect %>%\n#   summarize(commuters = sum(commuters))\n#167409 commuters that change tracts\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\ndf_linestrings_chloro_intersect <- df_linestrings_chloro_intersect %>% \n  mutate_at(vars(contains(\"intersect\")), ~case_when(is.na(.) ~ FALSE,\n                           !is.na(.) ~ .)) %>%\n  mutate(no_intersect = case_when(intersects_allegheny == FALSE & intersects_monongahela == FALSE & intersects_ohio == FALSE ~ TRUE,\n                                  TRUE ~ FALSE)) %>% \n  select(line_id, from, contains(\"intersect\"), commuters) %>% \n  pivot_longer(contains(\"intersect\"), names_to = \"river_intersected\", values_to = \"value\")\n\n# df_linestrings_chloro_intersect %>%\n#   distinct(line_id, commuters) %>%\n#   summarize(commuters = sum(commuters))\n#167409 commuters that change tracts\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\ndf_linestrings_chloro_intersect <- df_linestrings_chloro_intersect %>% \n  mutate(commuters = case_when(value == FALSE ~ 0,\n                               TRUE ~ commuters))\n\n# df_linestrings_chloro_intersect %>%\n#   distinct(line_id, commuters) %>%\n#   summarize(commuters = sum(commuters))\n#167409 commuters that change tracts\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\ndf_linestrings_chloro_intersect <- df_linestrings_chloro_intersect %>% \n  filter(value == TRUE) %>% \n  group_by(line_id, from, commuters) %>% \n  summarize(count_rivers_intersected = sum(river_intersected != \"no_intersect\")) %>% \n  ungroup()\n\n# df_linestrings_chloro_intersect %>%\n#   summarize(commuters = sum(commuters))\n#167409 commuters that change tracts  \n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\ndf_points_chloro <- cbind(df_points_chloro, st_coordinates(st_centroid(df_points_chloro))) %>% \n  st_drop_geometry() %>% \n  rename(from = name) %>% \n  distinct(from, line_id, commuters) %>% \n  mutate(count_rivers_intersected = 0)\n  \n\n# df_points_chloro %>%\n#    summarize(commuters = sum(commuters))\n#16995 commuters that stay within a tract\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\ndf_combined <- bind_rows(df_linestrings_chloro_intersect, df_points_chloro)\n\n# df_combined %>%\n#     filter(is.na(from))\n# \n# df_combined %>%\n#    summarize(commuters = sum(commuters))\n#184404 total commuters\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\ndf_combined <- df_combined %>% \n  arrange(from, desc(count_rivers_intersected), desc(commuters))\n```\n:::\n\n\nThese are the final steps to create the chloropleth:\n\n::: {.cell}\n\n```{.r .cell-code}\ndf_combined\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 2,969 × 4\n   line_id from        commuters count_rivers_intersected\n     <int> <chr>           <dbl>                    <dbl>\n 1     748 42003010300        63                        0\n 2    2192 42003020100        31                        2\n 3    1372 42003020100        42                        1\n 4    2282 42003020100        30                        1\n 5       1 42003020100       723                        0\n 6     632 42003020100        70                        0\n 7     730 42003020100        64                        0\n 8    1102 42003020100        49                        0\n 9    1761 42003020100        36                        0\n10     350 42003020300       112                        0\n# ℹ 2,959 more rows\n```\n:::\n:::\n\n\nThis counts the number of commuters per \"from\" tract and \"count of rivers intersected\". Note that there are multiple rows per \"from\" tract.\n\n::: {.cell}\n\n```{.r .cell-code}\ndf_chloro_map <- df_combined %>%\n  ungroup() %>% \n  group_by(from, count_rivers_intersected) %>% \n  summarize(total_commuters = sum(commuters)) %>% \n  ungroup()\n\ndf_chloro_map\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 723 × 3\n   from        count_rivers_intersected total_commuters\n   <chr>                          <dbl>           <dbl>\n 1 42003010300                        0              63\n 2 42003020100                        0             942\n 3 42003020100                        1              72\n 4 42003020100                        2              31\n 5 42003020300                        0             258\n 6 42003030500                        0             231\n 7 42003040200                        0             143\n 8 42003040400                        0             108\n 9 42003040500                        0              87\n10 42003040600                        0              59\n# ℹ 713 more rows\n```\n:::\n\n```{.r .cell-code}\n# df_chloro_map %>%\n#   filter(is.na(count_rivers_intersected))\n# \n# df_chloro_map %>% \n#     summarize(commuters = sum(total_commuters))\n#184404 total commuters\n```\n:::\n\n\nThe next step is to calculate the percent of a \"from\" tract's commuters that crossed a given number of rivers:\n\n::: {.cell}\n\n```{.r .cell-code}\ndf_chloro_map <- df_chloro_map %>% \n  group_by(from) %>% \n  mutate(pct_of_commuters = total_commuters / sum(total_commuters)) %>% \n  ungroup()\n\ndf_chloro_map\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 723 × 4\n   from        count_rivers_intersected total_commuters pct_of_commuters\n   <chr>                          <dbl>           <dbl>            <dbl>\n 1 42003010300                        0              63           1     \n 2 42003020100                        0             942           0.901 \n 3 42003020100                        1              72           0.0689\n 4 42003020100                        2              31           0.0297\n 5 42003020300                        0             258           1     \n 6 42003030500                        0             231           1     \n 7 42003040200                        0             143           1     \n 8 42003040400                        0             108           1     \n 9 42003040500                        0              87           1     \n10 42003040600                        0              59           1     \n# ℹ 713 more rows\n```\n:::\n\n```{.r .cell-code}\n# df_chloro_map %>% \n#   summarize(commuters = sum(total_commuters))\n#184404 total commuters\n```\n:::\n\n\nThen I join `df_chloro_map` against the census tract geometry to get a complete list of all the tracts. I use `complete` to add rows for combinations of \"from\" tracts and `count_rivers_intersected` that did not appear in the data. Those added rows are given `0` for `pct_of_commuters` and `total_commuters`.\n\n::: {.cell}\n\n```{.r .cell-code}\ndf_chloro_map <- df_chloro_map %>% \n  right_join(allegheny_tracts %>% select(GEOID) %>% st_set_geometry(NULL), by = c(\"from\" = \"GEOID\")) %>% \n  complete(from, count_rivers_intersected = c(0, 1, 2)) %>%\n  filter(!is.na(count_rivers_intersected)) %>% #exclude tracts brought in from the right_join\n  replace_na(list(pct_of_commuters = 0, total_commuters = 0))\n\n# df_chloro_map %>% \n#   filter(is.na(count_rivers_intersected))\n# \n# df_chloro_map %>% \n#   summarize(commuters = sum(total_commuters, na.rm = TRUE))\n#184404 total commuters\n```\n:::\n\n\nThe final step is to right join againt the census tract data to bring over the geometry.\n\n::: {.cell}\n\n```{.r .cell-code}\ndf_chloro_map <- df_chloro_map %>% \n  right_join(allegheny_tracts, by = c(\"from\" = \"GEOID\"))\n\nglimpse(df_chloro_map)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nRows: 1,206\nColumns: 7\n$ from                     <chr> \"42003010300\", \"42003010300\", \"42003010300\", …\n$ count_rivers_intersected <dbl> 0, 1, 2, 0, 1, 2, 0, 1, 2, 0, 1, 2, 0, 1, 2, …\n$ total_commuters          <dbl> 63, 0, 0, 942, 72, 31, 258, 0, 0, 231, 0, 0, …\n$ pct_of_commuters         <dbl> 1.00000000, 0.00000000, 0.00000000, 0.9014354…\n$ NAME                     <chr> \"Census Tract 103, Allegheny County, Pennsylv…\n$ total_pop                <dbl> 6600, 6600, 6600, 3629, 3629, 3629, 616, 616,…\n$ geometry                 <MULTIPOLYGON [°]> MULTIPOLYGON (((-79.98077 4..., …\n```\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\ndf_chloro_map %>% \n  mutate(count_rivers_intersected = str_c(\"Rivers intersected:\", count_rivers_intersected, sep = \" \")) %>% \n  ggplot() +\n    geom_sf(aes(geometry = geometry,\n                fill = pct_of_commuters),\n            color = NA) +\n    geom_sf(data = rivers,\n            aes(color = NAME),\n            size = 1,\n            show.legend = FALSE) +\n    facet_wrap(~count_rivers_intersected,\n               nrow = 1) +\n    scale_fill_viridis_c(\"% of commuters\",\n                         labels = scales::percent) +\n    labs(title = \"Commuter travel patterns\",\n         subtitle = \"2017 U.S. Census LODES dataset\",\n         caption = \"@conor_tompkins\") +\n    theme_void()\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-42-1.png){width=672}\n:::\n:::\n\n\n\n\n### Errata\n\nThe previous version of the bar chart double counted the commuters. This is the old version:\n\n::: {.cell}\n\n```{.r .cell-code}\ndf_commuter_rivers_summary <- df_commuter_rivers %>% \n  bind_rows(df_points %>% \n              mutate(value = FALSE)) %>% \n  group_by(line_id) %>% \n  summarize(rivers_crossed = sum(value),\n            commuters = sum(commuters))\n\ndf_commuter_rivers_summary %>% \n  st_drop_geometry() %>%\n  group_by(rivers_crossed) %>% \n  summarize(commuters = sum(commuters)) %>% \n  ggplot(aes(rivers_crossed, commuters)) +\n    geom_col() +\n    scale_y_continuous(labels = scales::comma) +\n    labs(title = \"Commuter travel patterns\",\n         subtitle = \"2017 U.S. Census LODES dataset\",\n         x = \"Rivers crossed\",\n         y = \"Number of commuters\",\n         caption = \"@conor_tompkins\") +\n    theme_bw()\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-44-1.png){width=672}\n:::\n:::\n\n\nA similar but less impactful bug affected the chloropleth chart. For completeness, this is the old verison of that graph:\n![](faceted_graph.png){width=80% height=80%}\n\n\n### References\n\n* https://lehd.ces.census.gov/data/\n* https://lehd.ces.census.gov/data/lodes/LODES7/LODESTechDoc7.4.pdf\n* https://lehd.ces.census.gov/doc/workshop/2017/Presentations/TheaEvans.pdf\n* https://medium.com/@urban_institute/open-accessible-data-on-jobs-and-workers-tract-level-lodes-data-945fcac9e280",
    "supporting": [
      "index_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}