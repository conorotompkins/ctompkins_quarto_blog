{
  "hash": "42578e33e9130e5df19c70ae07c026e4",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: Forecasting Pittsburgh Potholes with {fable}\nauthor: Conor Tompkins\ndate: '2023-10-28'\nslug: forecasting-pittsburgh-potholes-with-fable\ncategories: []\ntags: []\nsubtitle: ''\nsummary: ''\nauthors: []\nlastmod: '2023-10-28T09:50:42-04:00'\nfeatured: no\nimage: featured.png\nexecute: \n  echo: true\n  warning: false\n  message: false\neditor_options: \n  chunk_output_type: console\n---\n\n\n\n## Intro\n\nPotholes are the [bane](https://www.wtae.com/article/pittsburgh-pothole-season/42679802) of Pittsburgh drivers' existence. You can either weave around the [minefield](https://www.reddit.com/r/pittsburgh/comments/7y7rpe/challenge_level_40th_street_bridge_potholes/) of holes in the road (some of [alarming](https://www.reddit.com/r/pittsburgh/comments/8td27k/watch_out_for_them_potholes_southside/) size) or risk [damage to your vehicle](https://www.reddit.com/r/pittsburgh/comments/8175li/when_a_pothole_takes_your_whole_tire/). Drastic swings in weather also exacerbate the natural freeze-thaw cycle. The winter of 2017/2018 was a particularly bad year for potholes in the region.\n\nIn this post I will use `{fable}` and related `{tidyverts}` packages to model the number of reports about potholes to Pittsburgh's 311 service. The report data is available [here](https://data.wprdc.org/dataset/311-data).\n\n## EDA\n\n### Pothole data from 311\n\nThis code loads the relevant packages:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(fpp3)\nlibrary(tidyverse)\nlibrary(janitor)\nlibrary(future)\nlibrary(hrbrthemes)\n\ntheme_set(theme_ipsum())\n\nplan(multisession)\n\noptions(scipen = 999, digits = 4)\n```\n:::\n\n\n\nThis code reads in CSV containing the 311 data and filters to only the pothole complaints.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n#read in pothole data\npothole_data <- read_csv(\"post_data/wprdc_311.csv\") |> \n  clean_names() |> \n  filter(request_type == \"Potholes\") |> \n  mutate(created_yearmonth = yearmonth(created_on))\n```\n:::\n\n\n\nNext, summarize the data by year and month, and convert the data into a time series `tsibble`.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n#create basic tsibble\npothole_df <- pothole_data |> \n  group_by(created_yearmonth, request_type) |> \n  summarize(report_count = n()) |> \n  ungroup() |>\n  as_tsibble()\n\npothole_df\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tsibble: 93 x 3 [1M]\n   created_yearmonth request_type report_count\n               <mth> <chr>               <int>\n 1          2015 Apr Potholes              906\n 2          2015 May Potholes             1493\n 3          2015 Jun Potholes             1236\n 4          2015 Jul Potholes             1288\n 5          2015 Aug Potholes              734\n 6          2015 Sep Potholes              526\n 7          2015 Oct Potholes              516\n 8          2015 Nov Potholes              890\n 9          2015 Dec Potholes              309\n10          2016 Jan Potholes              222\n# ℹ 83 more rows\n```\n\n\n:::\n:::\n\n\n\n`{tidyverts}` provides some out-of-the-box functions to visualize the time series data. This is an important step to understand the dynamics of the data.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nautoplot(pothole_df)\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-4-1.png){width=672}\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\ngg_season(pothole_df)\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-5-1.png){width=672}\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\ngg_subseries(pothole_df) +\n  facet_wrap(vars(month(created_yearmonth)))\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-6-1.png){width=672}\n:::\n:::\n\n\n\nDecomposing a time series into components (trend, seasonality, remainder) gives a more detailed view into how the series behaves.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndcmp <- pothole_df |>\n  model(stl = STL(report_count, robust = TRUE))\n\ndcmp_components <- components(dcmp)\n\ndcmp_components\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A dable: 93 x 7 [1M]\n# Key:     .model [1]\n# :        report_count = trend + season_year + remainder\n   .model created_yearmonth report_count trend season_year remainder\n   <chr>              <mth>        <int> <dbl>       <dbl>     <dbl>\n 1 stl             2015 Apr          906 1179.        369.   -641.  \n 2 stl             2015 May         1493 1128.        353.     11.9 \n 3 stl             2015 Jun         1236 1077.        123.     36.7 \n 4 stl             2015 Jul         1288 1026.        117.    145.  \n 5 stl             2015 Aug          734  978.       -160.    -83.1 \n 6 stl             2015 Sep          526  929.       -353.    -50.7 \n 7 stl             2015 Oct          516  881.       -374.      8.42\n 8 stl             2015 Nov          890  836.       -480.    534.  \n 9 stl             2015 Dec          309  791.       -503.     21.5 \n10 stl             2016 Jan          222  746.       -402.   -122.  \n# ℹ 83 more rows\n# ℹ 1 more variable: season_adjust <dbl>\n```\n\n\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\ndcmp_components |> \n  autoplot()\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-8-1.png){width=672}\n:::\n:::\n\n\n\nYou can use the remainders to look for outliers in the data.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\noutliers <- dcmp_components |>\n  filter(\n    remainder < quantile(remainder, 0.25) - 3*IQR(remainder) |\n    remainder > quantile(remainder, 0.75) + 3*IQR(remainder)\n  )\n\noutliers |> \n  select(created_yearmonth, remainder)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tsibble: 10 x 2 [1M]\n   created_yearmonth remainder\n               <mth>     <dbl>\n 1          2016 Feb    -1011.\n 2          2017 Feb     -939.\n 3          2018 Jan     1572.\n 4          2018 Feb     2640.\n 5          2018 Apr     1641.\n 6          2018 May      982.\n 7          2018 Jun      726.\n 8          2020 Feb     -863.\n 9          2020 Apr     -772.\n10          2021 Feb    -1011.\n```\n\n\n:::\n:::\n\n\n\nThe winter of 2017/2018 clearly had many outliers.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\npothole_df |>\n  ggplot(aes(created_yearmonth, report_count)) +\n  geom_line() +\n  geom_point(data = outliers, color = \"red\")\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-10-1.png){width=672}\n:::\n:::\n\n\n\n## Train/test approach\n\nThe classic method for determining the accuracy of any model is to train the model on a subset of the data and test the model against another subset. This code splits the time series into 80% training and 20% testing sets.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n#split into train/test and forecast\ndata_test <- pothole_df |> \n  slice_tail(prop = .2)\n\ndata_train <- pothole_df |> \n  anti_join(data_test, by = \"created_yearmonth\")\n```\n:::\n\n\n\nI fit 3 models against the training set:\n\n-   ARIMA\n\n-   Exponential smoothing\n\n-   Linear model with seasonal effects\n\nI transform the data with `log()` and add 1 to the result to guarantee that the forecasts are positive. This is necessary because many of the observations are close to zero, and the models would not know otherwise that the count of pothole complaints cannot be negative. `{fable}` automatically back-transforms the forecast onto the original scale of the data.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmodel_df <- data_train |> \n    model(arima = ARIMA(log(report_count + 1)),\n          ets = ETS(log(report_count + 1)),\n          lm_seasonal = TSLM(log(report_count + 1) ~ trend() + season()))\n```\n:::\n\n\n\nThe `forecast()` function returns the full (transformed) distribution of the forecast and the mean of that distribution.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\npothole_fc <- model_df |> \n  forecast(data_test)\n\npothole_fc\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A fable: 54 x 5 [1M]\n# Key:     .model [3]\n   .model created_yearmonth    report_count .mean request_type\n   <chr>              <mth>          <dist> <dbl> <chr>       \n 1 arima           2021 Jul t(N(5.4, 0.25)) 237.  Potholes    \n 2 arima           2021 Aug t(N(5.1, 0.32)) 195.  Potholes    \n 3 arima           2021 Sep t(N(4.9, 0.34)) 151.  Potholes    \n 4 arima           2021 Oct t(N(4.9, 0.36)) 162.  Potholes    \n 5 arima           2021 Nov t(N(4.4, 0.38))  98.0 Potholes    \n 6 arima           2021 Dec t(N(4.2, 0.41))  77.0 Potholes    \n 7 arima           2022 Jan t(N(4.7, 0.43)) 129.  Potholes    \n 8 arima           2022 Feb t(N(5.6, 0.45)) 335.  Potholes    \n 9 arima           2022 Mar t(N(5.8, 0.47)) 423.  Potholes    \n10 arima           2022 Apr t(N(6.4, 0.49)) 764.  Potholes    \n# ℹ 44 more rows\n```\n\n\n:::\n:::\n\n\n\n`{fabletools}` provides many measures of forecast accuracy. I focus on the following:\n\n-   CPRS (skill score): [CPRS](https://otexts.com/fpp3/distaccuracy.html) measures how well the forecast distribution fits the test data. The `skill_score` function compares this to the CPRS of a naive model. This results in a measure how much accuracy the model is adding over a naive model.\n\n-   RMSE: Root Mean Squared Error\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nfc_acc <- pothole_fc |> \n  accuracy(pothole_df,\n           measures = list(point_accuracy_measures, distribution_accuracy_measures, skill_cprs = skill_score(CRPS))) |> \n  select(.model, .type, skill_cprs, RMSE) |> \n  arrange(desc(skill_cprs))\n\nfc_acc\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 3 × 4\n  .model      .type skill_cprs  RMSE\n  <chr>       <chr>      <dbl> <dbl>\n1 lm_seasonal Test       0.616  183.\n2 ets         Test       0.585  200.\n3 arima       Test       0.486  246.\n```\n\n\n:::\n:::\n\n\n\nThe `lm_seasonal` model provides the most accurate distribution and average forecast.\n\nThe `autoplot` function automatically extracts the 80% and 95% prediction intervals from the forecast distribution. You can see that the 80% interval of the `lm_seasonal` model fully contains the actual observations.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\npothole_fc |> \n  autoplot(pothole_df |> \n             filter(year(created_yearmonth) >= 2021)) +\n  facet_wrap(vars(.model), scales = \"free_y\", ncol = 1)\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-15-1.png){width=672}\n:::\n:::\n\n\n\nThe `report` function provides the details of the specified model:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmodel_df |> \n  select(lm_seasonal) |> \n  report()\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nSeries: report_count \nModel: TSLM \nTransformation: log(report_count + 1) \n\nResiduals:\n    Min      1Q  Median      3Q     Max \n-1.1790 -0.4089 -0.0561  0.3659  1.5638 \n\nCoefficients:\n               Estimate Std. Error t value             Pr(>|t|)    \n(Intercept)     6.71860    0.28196   23.83 < 0.0000000000000002 ***\ntrend()        -0.01324    0.00328   -4.04              0.00015 ***\nseason()year2   0.55293    0.35301    1.57              0.12237    \nseason()year3   0.87219    0.35306    2.47              0.01626 *  \nseason()year4   0.62630    0.34030    1.84              0.07049 .  \nseason()year5   0.67473    0.34022    1.98              0.05178 .  \nseason()year6   0.47684    0.34017    1.40              0.16597    \nseason()year7   0.37048    0.35355    1.05              0.29876    \nseason()year8   0.05145    0.35338    0.15              0.88472    \nseason()year9  -0.31460    0.35324   -0.89              0.37659    \nseason()year10 -0.37161    0.35314   -1.05              0.29674    \nseason()year11 -0.54787    0.35306   -1.55              0.12581    \nseason()year12 -0.92564    0.35301   -2.62              0.01098 *  \n---\nSignif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1\n\nResidual standard error: 0.611 on 62 degrees of freedom\nMultiple R-squared: 0.54,\tAdjusted R-squared: 0.451\nF-statistic: 6.08 on 12 and 62 DF, p-value: 0.00000068\n```\n\n\n:::\n:::\n\n\n\nThis code refits the `lm_seasonal` model against the entire `pothole_df` dataset and produces a true forecast with a 12 month horizon. The distribution reflects the uncertainty from the variation in previous years. The model forecasts that the overall downward trend will continue.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nfinal_model <- model_df |> \n  select(lm_seasonal) |> \n  refit(pothole_df, reestimate = TRUE)\n\nfinal_model |> \n  forecast(h = 12) |> \n  autoplot(pothole_df)\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-17-1.png){width=672}\n:::\n:::\n\n\n\n## Cross-validation approach\n\nCross-validation is the more robust way to measure the accuracy of a model. Instead of splitting the data into train/test sets, I create multiple subsets of the data with increasing origin points. This code creates the CV set by starting with the first 36 observations and adding 1 observation at a time to the rolling origin.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\npothole_cv <- stretch_tsibble(pothole_df, .step = 1, .init = 36) |> \n  relocate(created_yearmonth, .id)\n\npothole_cv\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tsibble: 3,741 x 4 [1M]\n# Key:       .id [58]\n   created_yearmonth   .id request_type report_count\n               <mth> <int> <chr>               <int>\n 1          2015 Apr     1 Potholes              906\n 2          2015 May     1 Potholes             1493\n 3          2015 Jun     1 Potholes             1236\n 4          2015 Jul     1 Potholes             1288\n 5          2015 Aug     1 Potholes              734\n 6          2015 Sep     1 Potholes              526\n 7          2015 Oct     1 Potholes              516\n 8          2015 Nov     1 Potholes              890\n 9          2015 Dec     1 Potholes              309\n10          2016 Jan     1 Potholes              222\n# ℹ 3,731 more rows\n```\n\n\n:::\n:::\n\n\n\nEach CV `.id` contains one more observation than the previous `.id`.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\npothole_cv |> \n  count(.id)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 58 × 2\n     .id     n\n   <int> <int>\n 1     1    36\n 2     2    37\n 3     3    38\n 4     4    39\n 5     5    40\n 6     6    41\n 7     7    42\n 8     8    43\n 9     9    44\n10    10    45\n# ℹ 48 more rows\n```\n\n\n:::\n:::\n\n\n\nThis code refits the models against the cross-validation set. The `{fable}` package automatically finds the appropriate model parameters for ARIMA and ETS models. Since each `.id` has a different subset of the data, the model parameters can be different for each `.id`.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmodels_cv <- pothole_cv |> \n    model(arima = ARIMA(log(report_count + 1)),\n          ets = ETS(log(report_count + 1)),\n          lm_seasonal = TSLM(log(report_count + 1) ~ trend() + season()))\n\nmodels_cv\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A mable: 58 x 4\n# Key:     .id [58]\n     .id                     arima          ets lm_seasonal\n   <int>                   <model>      <model>     <model>\n 1     1 <ARIMA(0,0,1)(0,1,0)[12]> <ETS(A,N,N)>      <TSLM>\n 2     2 <ARIMA(0,1,1)(0,1,0)[12]> <ETS(A,N,N)>      <TSLM>\n 3     3 <ARIMA(0,1,1)(0,1,0)[12]> <ETS(A,N,N)>      <TSLM>\n 4     4 <ARIMA(0,1,1)(0,1,0)[12]> <ETS(A,N,N)>      <TSLM>\n 5     5 <ARIMA(0,1,1)(0,1,0)[12]> <ETS(A,N,N)>      <TSLM>\n 6     6 <ARIMA(0,1,1)(0,1,0)[12]> <ETS(A,N,N)>      <TSLM>\n 7     7 <ARIMA(0,1,1)(1,1,0)[12]> <ETS(A,N,N)>      <TSLM>\n 8     8 <ARIMA(0,1,1)(1,1,0)[12]> <ETS(A,N,N)>      <TSLM>\n 9     9 <ARIMA(0,1,1)(1,1,0)[12]> <ETS(A,N,N)>      <TSLM>\n10    10 <ARIMA(0,1,1)(0,1,0)[12]> <ETS(A,N,N)>      <TSLM>\n# ℹ 48 more rows\n```\n\n\n:::\n:::\n\n\n\nNext we forecast for each model and `.id` with a 12 month horizon.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nforecast_cv <- models_cv |> \n    forecast(h = 12)\n\nforecast_cv\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A fable: 2,088 x 5 [1M]\n# Key:     .id, .model [174]\n     .id .model created_yearmonth    report_count .mean\n   <int> <chr>              <mth>          <dist> <dbl>\n 1     1 arima           2018 Apr  t(N(6.7, 0.4))  955.\n 2     1 arima           2018 May   t(N(7, 0.47)) 1347.\n 3     1 arima           2018 Jun t(N(6.8, 0.47)) 1089.\n 4     1 arima           2018 Jul t(N(6.7, 0.47))  991.\n 5     1 arima           2018 Aug t(N(6.4, 0.47))  767.\n 6     1 arima           2018 Sep t(N(5.9, 0.47))  457.\n 7     1 arima           2018 Oct t(N(5.6, 0.47))  344.\n 8     1 arima           2018 Nov t(N(5.3, 0.47))  256.\n 9     1 arima           2018 Dec t(N(4.9, 0.47))  162.\n10     1 arima           2019 Jan t(N(7.6, 0.47)) 2469.\n# ℹ 2,078 more rows\n```\n\n\n:::\n:::\n\n\n\nYou can see that each `.id` gains one observation, and the model forecasts reflect that difference. This code graphs every 10th `.id`.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nforecast_cv |> \n  filter(.id %in% seq(min(.id), max(.id), 10)) |> \n  autoplot(pothole_cv) +\n  facet_wrap(vars(.id), ncol = 2, scales = \"free_y\")\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-22-1.png){width=672}\n:::\n:::\n\n\n\nThe forecast accuracy for each model is averaged across all the `.id`s. This gives a more robust estimation of accuracy.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncv_acc <- forecast_cv |> \n    accuracy(pothole_df, measures = list(point_accuracy_measures, distribution_accuracy_measures, skill_cprs = skill_score(CRPS))) |> \n    select(.model, .type, skill_cprs, RMSE) |> \n    arrange(desc(skill_cprs))\n\ncv_acc |> \n  arrange(desc(skill_cprs))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 3 × 4\n  .model      .type skill_cprs  RMSE\n  <chr>       <chr>      <dbl> <dbl>\n1 lm_seasonal Test       0.716  592.\n2 ets         Test       0.622 1347.\n3 arima       Test       0.465 1958.\n```\n\n\n:::\n:::\n\n\n\nOn average, the `lm_seasonal` model provides more accurate forecasts.\n\nThe basic models have higher CV accuracy than ARIMA, which probably shows that the more complicated ARIMA model over-fits the training data.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nfc_acc |> \n  mutate(type = \"train_test\") |> \n  bind_rows(cv_acc |> \n              mutate(type = \"cv\")) |> \n  select(.model, type, skill_cprs) |> \n  pivot_wider(names_from = type, values_from = skill_cprs)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 3 × 3\n  .model      train_test    cv\n  <chr>            <dbl> <dbl>\n1 lm_seasonal      0.616 0.716\n2 ets              0.585 0.622\n3 arima            0.486 0.465\n```\n\n\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nsessionInfo()\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nR version 4.4.1 (2024-06-14)\nPlatform: x86_64-apple-darwin20\nRunning under: macOS 15.1.1\n\nMatrix products: default\nBLAS:   /Library/Frameworks/R.framework/Versions/4.4-x86_64/Resources/lib/libRblas.0.dylib \nLAPACK: /Library/Frameworks/R.framework/Versions/4.4-x86_64/Resources/lib/libRlapack.dylib;  LAPACK version 3.12.0\n\nlocale:\n[1] en_US.UTF-8/en_US.UTF-8/en_US.UTF-8/C/en_US.UTF-8/en_US.UTF-8\n\ntime zone: America/New_York\ntzcode source: internal\n\nattached base packages:\n[1] stats     graphics  grDevices datasets  utils     methods   base     \n\nother attached packages:\n [1] hrbrthemes_0.8.7  future_1.34.0     janitor_2.2.0     forcats_1.0.0    \n [5] stringr_1.5.1     purrr_1.0.2       readr_2.1.5       tidyverse_2.0.0  \n [9] fable_0.4.1       feasts_0.4.1      fabletools_0.5.0  tsibbledata_0.4.1\n[13] tsibble_1.1.5     ggplot2_3.5.1     lubridate_1.9.3   tidyr_1.3.1      \n[17] dplyr_1.1.4       tibble_3.2.1      fpp3_1.0.1       \n\nloaded via a namespace (and not attached):\n [1] gtable_0.3.5            anytime_0.3.9           xfun_0.49              \n [4] htmlwidgets_1.6.4       numDeriv_2016.8-1.1     tzdb_0.4.0             \n [7] vctrs_0.6.5             tools_4.4.1             generics_0.1.3         \n[10] parallel_4.4.1          fansi_1.0.6             pkgconfig_2.0.3        \n[13] distributional_0.5.0    lifecycle_1.0.4         farver_2.1.2           \n[16] compiler_4.4.1          munsell_0.5.1           codetools_0.2-20       \n[19] snakecase_0.11.1        fontLiberation_0.1.0    fontquiver_0.2.1       \n[22] htmltools_0.5.8.1       yaml_2.3.10             Rttf2pt1_1.3.12        \n[25] pillar_1.9.0            crayon_1.5.3            extrafontdb_1.0        \n[28] ellipsis_0.3.2          fontBitstreamVera_0.1.1 parallelly_1.38.0      \n[31] tidyselect_1.2.1        digest_0.6.37           stringi_1.8.4          \n[34] listenv_0.9.1           labeling_0.4.3          extrafont_0.19         \n[37] fastmap_1.2.0           grid_4.4.1              colorspace_2.1-1       \n[40] cli_3.6.3               magrittr_2.0.3          utf8_1.2.4             \n[43] future.apply_1.11.2     withr_3.0.1             gdtools_0.4.0          \n[46] scales_1.3.0            rappdirs_0.3.3          bit64_4.0.5            \n[49] timechange_0.3.0        rmarkdown_2.28          globals_0.16.3         \n[52] bit_4.0.5               progressr_0.14.0        hms_1.1.3              \n[55] evaluate_0.24.0         knitr_1.48              ggdist_3.3.2           \n[58] rlang_1.1.4             Rcpp_1.0.13             glue_1.8.0             \n[61] renv_1.0.11             vroom_1.6.5             rstudioapi_0.16.0      \n[64] jsonlite_1.8.8          R6_2.5.1                systemfonts_1.1.0      \n```\n\n\n:::\n:::\n",
    "supporting": [
      "index_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}