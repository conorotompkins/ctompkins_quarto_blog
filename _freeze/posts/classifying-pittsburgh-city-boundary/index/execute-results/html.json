{
  "hash": "689365490b048ad7f6b4809b56d32934",
  "result": {
    "markdown": "---\ntitle: \"Modeling the Pittsburgh City Boundary\"\nsubtitle: \"\"\nsummary: \"In this post I create a model that differentiates census tracts that are inside and outside the city limits of Pittsburgh\"\nauthor: \"Conor Tompkins\"\ndate: 2020-08-14\nlastmod: 2020-08-14T12:58:17-04:00\neditor_options: \n  chunk_output_type: console\nexecute:\n  echo: true\n  warning: false\n  message: false\n---\n\n\n## Introduction\n\nMy goal is to create a classification model that can distinguish between census tracts that are inside the city or outside the City of Pittsburgh. The border is interrupted by rivers, has an enclave, and is very irregular in general, which made this an interesting intellectual exercise.\n\n### City of Pittsburgh Border\n\nWhile Pittsburgh was founded in 1758, the city's borders have changed many times due to annexation of surrounding municipalities. [This map](https://en.wikipedia.org/wiki/Allegheny,_Pennsylvania) shows that what we call the North Side was previously Allegheny City, and was annexed into the city in 1907.\n\n![](https://upload.wikimedia.org/wikipedia/commons/f/fd/Allegheny_City.jpg)\n\nMt. Oliver is a geographic enclave that is completely surrounded by the City of Pittsburgh, but is a separate municipality. The borough has [resisted multiple annexation attempts](https://www.wesa.fm/post/how-mt-oliver-borough-eluded-city-pittsburgh-annexation#stream/0).\n\n![](mt_oliver.png)\n\n### Modeling\n\nThis code loads the packages I need, configures some options, and sets the seed.\n\n::: {.cell}\n\n```{.r .cell-code}\n#set up environment\nlibrary(tidyverse)\nlibrary(tidymodels)\nlibrary(janitor)\nlibrary(tidycensus)\nlibrary(sf)\nlibrary(hrbrthemes)\nlibrary(GGally)\n\ntheme_set(theme_ipsum(base_size = 15))\n\noptions(scipen = 999, digits = 4, tigris_use_cache = TRUE)\n\nset.seed(1234)\n```\n:::\n\n\nI created a small Shiny app that let me select which tracts are inside the city borders. I will go over that in a future post. This loads the tracts from the Census API and pulls the results from the Shiny app.\n\n::: {.cell}\n\n```{.r .cell-code}\n#load data about census tracts\ntracts <- get_decennial(year = 2010, state = \"PA\", county = \"Allegheny County\", \n                        variables = \"P001001\",\n                        geography = \"tract\", geometry = TRUE)\n\ncity_tracts <- read_csv(\"post_data/selected_tracts.csv\", col_types = cols(\"c\", \"l\")) %>% \n  filter(selected == TRUE)\n\nglimpse(city_tracts)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nRows: 137\nColumns: 2\n$ GEOID    <chr> \"42003563000\", \"42003562800\", \"42003563100\", \"42003281500\", \"…\n$ selected <lgl> TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, T…\n```\n:::\n:::\n\n\nThis reads in the boundary shapefile and graphs it to show which tracts are in the city.\n\n::: {.cell}\n\n```{.r .cell-code}\npgh_official_boundary <- st_read(\"post_data/Pittsburgh_City_Boundary-shp\") %>% \n  mutate(geography = \"City boundary\") %>% \n  st_transform(crs = \"NAD83\") %>% \n  st_cast(\"POLYGON\") %>% \n  filter(FID != 7)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nReading layer `City_Boundary' from data source \n  `/Users/conorotompkins/Documents/github_repos/ctompkins_quarto_blog/posts/classifying-pittsburgh-city-boundary/post_data/Pittsburgh_City_Boundary-shp' \n  using driver `ESRI Shapefile'\nSimple feature collection with 8 features and 8 fields\nGeometry type: POLYGON\nDimension:     XY\nBounding box:  xmin: 1316000 ymin: 381900 xmax: 1380000 ymax: 433400\nProjected CRS: NAD83 / Pennsylvania South (ftUS)\n```\n:::\n\n```{.r .cell-code}\ntracts %>% \n  left_join(city_tracts) %>% \n  mutate(type = case_when(selected == TRUE ~ \"city\",\n                          is.na(selected) ~ \"non_city\")) %>% \n  ggplot() +\n  geom_sf(aes(fill = type), size = .1) +\n  geom_sf(data = pgh_official_boundary, color = \"white\", linetype = 2, alpha = 0) +\n  theme_void()\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-3-1.png){width=672}\n:::\n:::\n\nThis reads in the data I will consider for the model. All the data is from the 2010 Census.\n\n::: {.cell}\n\n```{.r .cell-code}\nall_data <- read_csv(\"post_data/combined_census_data_tract.csv\", col_types = cols(.default = \"c\")) %>%\n  left_join(city_tracts) %>% \n  mutate(type = case_when(selected == TRUE ~ \"city\",\n                          is.na(selected) ~ \"non_city\")) %>% \n  mutate(across(pct_units_owned_loan:housed_population_density_pop_per_square_km, as.numeric)) %>% \n  select(GEOID, type, everything()) %>%\n  select(-c(selected, total_population_housed))\n\nglimpse(all_data)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nRows: 402\nColumns: 13\n$ GEOID                                       <chr> \"42003010300\", \"4200302010…\n$ type                                        <chr> \"city\", \"city\", \"city\", \"c…\n$ pct_units_owned_loan                        <dbl> 0.137755, 0.119779, 0.0762…\n$ pct_units_owned_entire                      <dbl> 0.18367, 0.06619, 0.02110,…\n$ pct_units_rented                            <dbl> 0.6786, 0.8140, 0.9026, 0.…\n$ total_population                            <dbl> 6600, 3629, 616, 2256, 260…\n$ pct_white                                   <dbl> 0.658333, 0.745660, 0.7564…\n$ pct_black                                   <dbl> 0.31167, 0.15982, 0.15584,…\n$ pct_asian                                   <dbl> 0.0110606, 0.0471204, 0.06…\n$ pct_hispanic                                <dbl> 0.024394, 0.032791, 0.0162…\n$ workers                                     <dbl> 0, 963, 408, 1056, 537, 47…\n$ jobs                                        <dbl> 0, 79639, 8301, 4633, 1962…\n$ housed_population_density_pop_per_square_km <dbl> 682.7, 1511.3, 386.7, 3205…\n```\n:::\n:::\n\n\nThis plot compares all of the variables against each other. I used this to identify covariance and determine which variables should be excluded.\n\n::: {.cell}\n\n```{.r .cell-code}\n#eda\npairwise_plot <- all_data %>% \n  select(-c(GEOID)) %>% \n  ggpairs(aes(color = type)) +\n  theme(axis.text = element_text(size = 8))\n```\n:::\n\n\n![](ggpairs_plot.png)\nAfter reviewing this graph and considering things like covariance and zero-variance, I will use these variables in the model:\n\n* Housing\n  * Percent of housing units owned outright\n  * Percent of housing units owned with a mortgage\n  * Percent of housing units rented\n* Demographics\n  * Percent of people in the tract that are\n    * White\n    * Black\n* Population density\n* Economic data\n  * Number of workers that live in the tract\n  * Number of jobs in the tract\n\nNote that I am intentionally excluding any geographic data about the tracts. I am more interested in how \"city-like\" a given tract is than how close it is to the geographic center of the city.\n\nThis finalizes the data I will use to build the model.\n\n::: {.cell}\n\n```{.r .cell-code}\ncensus_combined <- all_data %>% \n  select(GEOID, type, \n         pct_units_owned_loan, pct_units_owned_entire, pct_units_rented,\n         housed_population_density_pop_per_square_km,\n         pct_white, pct_black,\n         workers, jobs)\n\nglimpse(census_combined)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nRows: 402\nColumns: 10\n$ GEOID                                       <chr> \"42003010300\", \"4200302010…\n$ type                                        <chr> \"city\", \"city\", \"city\", \"c…\n$ pct_units_owned_loan                        <dbl> 0.137755, 0.119779, 0.0762…\n$ pct_units_owned_entire                      <dbl> 0.18367, 0.06619, 0.02110,…\n$ pct_units_rented                            <dbl> 0.6786, 0.8140, 0.9026, 0.…\n$ housed_population_density_pop_per_square_km <dbl> 682.7, 1511.3, 386.7, 3205…\n$ pct_white                                   <dbl> 0.658333, 0.745660, 0.7564…\n$ pct_black                                   <dbl> 0.31167, 0.15982, 0.15584,…\n$ workers                                     <dbl> 0, 963, 408, 1056, 537, 47…\n$ jobs                                        <dbl> 0, 79639, 8301, 4633, 1962…\n```\n:::\n:::\n\n\n34% of the tracts are in the city, which is a slightly unbalanced dataset.\n\n::: {.cell}\n\n```{.r .cell-code}\ncensus_combined %>% \n  tabyl(type)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n     type   n percent\n     city 137  0.3408\n non_city 265  0.6592\n```\n:::\n:::\n\n\nSince the total amount of data available is small, I will bootstrap the data to try to achieve more stable results from the model. [Bootstrapping resamples the data with replacement](https://www.tidymodels.org/learn/statistics/bootstrap/), which creates multiple replicates of the original dataset with some variation due to sampling. I created a meme of my dog Quincy to illustrate the effect: ![](meme.jpg)\n\nI stratify by `type` so that each bootstrap has ~34% `city` tracts. This generates 50 sets of data for the model to work with.\n\n::: {.cell}\n\n```{.r .cell-code}\ntract_boot <- bootstraps(census_combined, strata = type, times = 50)\n\ntract_boot\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# Bootstrap sampling using stratification \n# A tibble: 50 × 2\n   splits            id         \n   <list>            <chr>      \n 1 <split [402/152]> Bootstrap01\n 2 <split [402/145]> Bootstrap02\n 3 <split [402/147]> Bootstrap03\n 4 <split [402/150]> Bootstrap04\n 5 <split [402/144]> Bootstrap05\n 6 <split [402/148]> Bootstrap06\n 7 <split [402/152]> Bootstrap07\n 8 <split [402/149]> Bootstrap08\n 9 <split [402/143]> Bootstrap09\n10 <split [402/156]> Bootstrap10\n# ℹ 40 more rows\n```\n:::\n:::\n\n\nThis code chunk prepares the data to be modeled. I define the formula and scale all the numeric variables to have a mean of 0 and standard deviation of 1.\n\n::: {.cell}\n\n```{.r .cell-code}\n#recipe\nmodel_recipe <- recipe(type ~ ., data = census_combined) %>% \n  update_role(GEOID, new_role = \"id\") %>% \n  step_normalize(all_predictors())\n\nmodel_recipe_prep <- model_recipe %>%\n  prep(strings_as_factors = FALSE)\n\nmodel_recipe %>% \n  summary()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 10 × 4\n   variable                                    type      role      source  \n   <chr>                                       <list>    <chr>     <chr>   \n 1 GEOID                                       <chr [3]> id        original\n 2 pct_units_owned_loan                        <chr [2]> predictor original\n 3 pct_units_owned_entire                      <chr [2]> predictor original\n 4 pct_units_rented                            <chr [2]> predictor original\n 5 housed_population_density_pop_per_square_km <chr [2]> predictor original\n 6 pct_white                                   <chr [2]> predictor original\n 7 pct_black                                   <chr [2]> predictor original\n 8 workers                                     <chr [2]> predictor original\n 9 jobs                                        <chr [2]> predictor original\n10 type                                        <chr [3]> outcome   original\n```\n:::\n:::\n\n\nThis creates the model specifications for the two types of models I will use.\n\n::: {.cell}\n\n```{.r .cell-code}\n#logistic regression\nlm_model <- logistic_reg(mode = \"classification\") %>% \n  set_engine(\"glm\")\n\n#random forest\nranger_model <- rand_forest(trees = 1000, mode = \"classification\") %>%\n  set_engine(\"ranger\", importance = \"impurity\")\n```\n:::\n\n\nThis sets up a workflow object to fit a logistic regression model against the bootstrap resamples I created earlier.\n\n::: {.cell hash='index_cache/html/unnamed-chunk-11_459b7c643c94277d2cd595b80cef3511'}\n\n```{.r .cell-code}\n#logistic regression\nlm_workflow <- workflow() %>% \n  add_recipe(model_recipe) %>% \n  add_model(lm_model)\n\nlm_res <- lm_workflow %>% \n  fit_resamples(resamples = tract_boot) %>% \n  mutate(model = \"lm\")\n\nlm_res %>% \n  collect_metrics()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 2 × 6\n  .metric  .estimator  mean     n std_err .config             \n  <chr>    <chr>      <dbl> <int>   <dbl> <chr>               \n1 accuracy binary     0.783    49 0.00383 Preprocessor1_Model1\n2 roc_auc  binary     0.856    49 0.00394 Preprocessor1_Model1\n```\n:::\n:::\n\n\nThe logistic regression gets ~76% accuracy, which is pretty good, but I want to know if a random forest could do better. This creates a workflow to fit a random forest model, and saves the predictions so I can use them later.\n\n::: {.cell hash='index_cache/html/unnamed-chunk-12_1f13a094b9cb1b4c18c146f1a277da16'}\n\n```{.r .cell-code}\n#rf\nrf_workflow <- workflow() %>% \n  add_recipe(model_recipe_prep) %>% \n  add_model(ranger_model)\n\nrf_res <- rf_workflow %>% \n  fit_resamples(resamples = tract_boot,\n                control = control_resamples(save_pred = TRUE)) %>% \n  mutate(model = \"rf\")\n\nrf_res %>% \n  collect_metrics()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 2 × 6\n  .metric  .estimator  mean     n std_err .config             \n  <chr>    <chr>      <dbl> <int>   <dbl> <chr>               \n1 accuracy binary     0.816    50 0.00360 Preprocessor1_Model1\n2 roc_auc  binary     0.894    50 0.00289 Preprocessor1_Model1\n```\n:::\n:::\n\n\nIf you compare the results of the two models, the random forest model does much better than the logistic regression model.\n\n::: {.cell}\n\n```{.r .cell-code}\ncombined_res <- bind_rows(rf_res, lm_res)\n\ncombined_res %>% \n  unnest(.metrics) %>% \n  ggplot(aes(.estimate, color = model, fill = model)) +\n  geom_density(alpha = .5) +\n  facet_wrap(~.metric)\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-13-1.png){width=672}\n:::\n:::\n\n\nThis graph shows that the random forest model's false negative and false positive rates are about the same.\n\n::: {.cell}\n\n```{.r .cell-code}\nrf_res %>% \n  collect_predictions() %>% \n  count(type, .pred_class) %>% \n  ggplot(aes(type, .pred_class, fill = n)) +\n  geom_tile() +\n  labs(x = \"Truth\",\n       y = \"Prediction\",\n       fill = \"Number of observations\") +\n  scale_fill_continuous(label = scales::comma) +\n  coord_equal() +\n  theme(panel.grid.major = element_blank())\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-14-1.png){width=672}\n:::\n:::\n\n\nThis fits the random forest model against the entire dataset to extract the variable importance metrics.\n\n::: {.cell}\n\n```{.r .cell-code}\n#variable importance\nvar_imp <- rf_workflow %>% \n  fit(juice(model_recipe_prep)) %>% \n  pull_workflow_fit() %>% \n  vip::vi()\n\nvar_imp %>%\n  mutate(Variable = fct_reorder(Variable, Importance)) %>% \n  ggplot(aes(Importance, Variable)) +\n  geom_point()\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-15-1.png){width=672}\n:::\n:::\n\n\nThe top 3 variables are the percent of a tract's population that is White, the percent of housing units that are owned with a loan, and the population density. This matches my subjective model of city vs. non-city characteristics. Areas that are low density with majority White demographics where people own their homes are typically outside of the city. This dynamic is probably connected to the [history of segregation and redlining](https://www.wesa.fm/post/pittsburgh-neighborhoods-and-schools-remain-segregated-how-did-it-start#stream/0) in majority African American communities in Pittsburgh.\n\nSince the random forest model was fit against multiple bootstraps, I have multiple predictions per tract. I stratified the bootstraps by `type`, so the `city` and `non_city` tracts were sampled about the same number of times.\n\n::: {.cell}\n\n```{.r .cell-code}\n#extract probabilities from bootstrap resamples\nfull_predictions <- rf_res %>% \n  collect_predictions() %>% \n  mutate(correct = type == .pred_class) %>%\n  left_join(census_combined %>%\n              mutate(.row = row_number()))\n\nfull_predictions %>% \n  count(type, GEOID) %>% \n  ggplot(aes(n, fill = type, color = type)) +\n  geom_density(alpha = .3) +\n  labs(x = \"Number of observations of a tract\")\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-16-1.png){width=672}\n:::\n:::\n\n\nI am not solely interested in the top-line accuracy of the model. Since the city border is a geographic phenomenon, there may be interesting patterns in the geographic distribution of the model's predictions that can be shown on a map.\n\nTo map the data, I calculate the following metrics per tract:\n\n* the percent of predictions that were correct\n* average city classification %\n* average non-city classification %\n* the number of times the tract was sampled\n\n\n::: {.cell}\n\n```{.r .cell-code}\nfull_predictions_pct <- full_predictions %>% \n  group_by(GEOID) %>% \n  summarize(pct_correct = mean(correct),\n            mean_city = mean(.pred_city),\n            mean_non_city = mean(.pred_non_city),\n            n = n())\n\nglimpse(full_predictions_pct)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nRows: 402\nColumns: 5\n$ GEOID         <chr> \"42003010300\", \"42003020100\", \"42003020300\", \"4200303050…\n$ pct_correct   <dbl> 1.00000, 1.00000, 1.00000, 1.00000, 1.00000, 1.00000, 1.…\n$ mean_city     <dbl> 0.7656, 0.7912, 0.8174, 0.7668, 0.7078, 0.8055, 0.9276, …\n$ mean_non_city <dbl> 0.23436, 0.20878, 0.18263, 0.23318, 0.29219, 0.19454, 0.…\n$ n             <int> 23, 13, 15, 21, 19, 17, 16, 19, 11, 20, 22, 21, 18, 22, …\n```\n:::\n:::\n\n\nThis shows the % of correct predictions per tract. The model was very successful with the outlying tracts in the county, but struggled in Mt. Washington/Beechview/Brookline, the Hazelwood/Greenfield area, and Forest Hills towards Monroeville.\n\n::: {.cell}\n\n```{.r .cell-code}\ntracts %>% \n  left_join(full_predictions_pct) %>% \n  ggplot() +\n  geom_sf(aes(fill = pct_correct), lwd = 0) +\n  geom_sf(data = pgh_official_boundary, alpha = 0, color = \"black\", lwd = 2) +\n  geom_sf(data = pgh_official_boundary, alpha = 0, color = \"yellow\", lwd = .3) +\n  scale_fill_viridis_c(labels = scales::percent) +\n  labs(fill = \"% predictions correct\") +\n  theme_void()\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-18-1.png){width=672}\n:::\n:::\n\n\nThis shows the average % that the model classified a tract as being in the city. The model was very confident that Oakland, Shadyside, and Squirrel Hill are in the city. The model also thought that many communities to the east and communities along the Monongahela River are in the city, specifically McKeesport and West Mifflin.\n\n::: {.cell}\n\n```{.r .cell-code}\ntracts %>% \n  left_join(full_predictions_pct) %>% \n  ggplot() +\n  geom_sf(aes(fill = mean_city), lwd = 0) +\n  geom_sf(data = pgh_official_boundary, alpha = 0, color = \"black\", lwd = 2) +\n  geom_sf(data = pgh_official_boundary, alpha = 0, color = \"yellow\", lwd = .3) +\n  scale_fill_viridis_c(labels = scales::percent) +\n  labs(fill = \"Average city classification %\") +\n  theme_void()\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-19-1.png){width=672}\n:::\n:::\n\nTo review, I think it would be difficult to create a model that almost perfectly captures the current city border, which is a result of political decisions, court cases, and other non-deterministic phenomena. In addition, white flight and the relative expansion of the suburbs during the collapse of the steel industry reshaped the Pittsburgh metro area. City borders are defined by people and politicians, not a clustering algorithm based on Census data (although that would be interesting). My experience is that many people that don't technically live within the border consider themselves to be Pittsburghers. So what is a border, anyways?\n\n## References\n\n* https://juliasilge.com/blog/multinomial-volcano-eruptions/\n* http://www.rebeccabarter.com/blog/2020-03-25_machine_learning/#split-into-traintest\n* https://www.brodrigues.co/blog/2018-11-25-tidy_cv/\n* https://agailloty.rbind.io/en/post/tidymodels/\n* https://alison.rbind.io/post/2020-02-27-better-tidymodels/\n* https://hansjoerg.me/2020/02/09/tidymodels-for-machine-learning/\n* https://towardsdatascience.com/modelling-with-tidymodels-and-parsnip-bae2c01c131c\n* https://www.benjaminsorensen.me/post/modeling-with-parsnip-and-tidymodels/\n* https://rviews.rstudio.com/2019/06/19/a-gentle-intro-to-tidymodels/\n* https://en.wikipedia.org/wiki/Allegheny,_Pennsylvania",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}